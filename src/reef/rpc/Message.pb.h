// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace reef {
namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class Message;
class Request;
class Invocation;
class Parameter;
class Any_PB;
class Complex_Type;
class Ref_Type;

enum Message_Type {
  Message_Type_INVOCATION = 0,
  Message_Type_REQUEST_NEW = 1,
  Message_Type_REQUEST_LOOKUP = 2,
  Message_Type_REQUEST_LEASE = 3,
  Message_Type_REQUEST_CANCEL_LEASE = 4,
  Message_Type_RETURN = 5
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_INVOCATION;
const Message_Type Message_Type_Type_MAX = Message_Type_RETURN;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum Ref_Type_Owner {
  Ref_Type_Owner_OWNER_SENDER = 0,
  Ref_Type_Owner_OWNER_RECEIVER = 1,
  Ref_Type_Owner_OWNER_ANOTHER = 2
};
bool Ref_Type_Owner_IsValid(int value);
const Ref_Type_Owner Ref_Type_Owner_Owner_MIN = Ref_Type_Owner_OWNER_SENDER;
const Ref_Type_Owner Ref_Type_Owner_Owner_MAX = Ref_Type_Owner_OWNER_ANOTHER;
const int Ref_Type_Owner_Owner_ARRAYSIZE = Ref_Type_Owner_Owner_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ref_Type_Owner_descriptor();
inline const ::std::string& Ref_Type_Owner_Name(Ref_Type_Owner value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ref_Type_Owner_descriptor(), value);
}
inline bool Ref_Type_Owner_Parse(
    const ::std::string& name, Ref_Type_Owner* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ref_Type_Owner>(
    Ref_Type_Owner_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_Type Type;
  static const Type INVOCATION = Message_Type_INVOCATION;
  static const Type REQUEST_NEW = Message_Type_REQUEST_NEW;
  static const Type REQUEST_LOOKUP = Message_Type_REQUEST_LOOKUP;
  static const Type REQUEST_LEASE = Message_Type_REQUEST_LEASE;
  static const Type REQUEST_CANCEL_LEASE = Message_Type_REQUEST_CANCEL_LEASE;
  static const Type RETURN = Message_Type_RETURN;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string requester_endpoint = 1;
  inline bool has_requester_endpoint() const;
  inline void clear_requester_endpoint();
  static const int kRequesterEndpointFieldNumber = 1;
  inline const ::std::string& requester_endpoint() const;
  inline void set_requester_endpoint(const ::std::string& value);
  inline void set_requester_endpoint(const char* value);
  inline void set_requester_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_requester_endpoint();
  inline ::std::string* release_requester_endpoint();
  
  // required .reef.rpc.Message.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::reef::rpc::Message_Type type() const;
  inline void set_type(::reef::rpc::Message_Type value);
  
  // optional .reef.rpc.Invocation invocation = 3;
  inline bool has_invocation() const;
  inline void clear_invocation();
  static const int kInvocationFieldNumber = 3;
  inline const ::reef::rpc::Invocation& invocation() const;
  inline ::reef::rpc::Invocation* mutable_invocation();
  inline ::reef::rpc::Invocation* release_invocation();
  
  // optional .reef.rpc.Request request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline const ::reef::rpc::Request& request() const;
  inline ::reef::rpc::Request* mutable_request();
  inline ::reef::rpc::Request* release_request();
  
  // optional .reef.rpc.Parameter ret_value = 5;
  inline bool has_ret_value() const;
  inline void clear_ret_value();
  static const int kRetValueFieldNumber = 5;
  inline const ::reef::rpc::Parameter& ret_value() const;
  inline ::reef::rpc::Parameter* mutable_ret_value();
  inline ::reef::rpc::Parameter* release_ret_value();
  
  // optional int32 ret_int = 6;
  inline bool has_ret_int() const;
  inline void clear_ret_int();
  static const int kRetIntFieldNumber = 6;
  inline ::google::protobuf::int32 ret_int() const;
  inline void set_ret_int(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:reef.rpc.Message)
 private:
  inline void set_has_requester_endpoint();
  inline void clear_has_requester_endpoint();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_invocation();
  inline void clear_has_invocation();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_ret_value();
  inline void clear_has_ret_value();
  inline void set_has_ret_int();
  inline void clear_has_ret_int();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* requester_endpoint_;
  ::reef::rpc::Invocation* invocation_;
  ::reef::rpc::Request* request_;
  int type_;
  ::google::protobuf::int32 ret_int_;
  ::reef::rpc::Parameter* ret_value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string new_instance_type = 2;
  inline bool has_new_instance_type() const;
  inline void clear_new_instance_type();
  static const int kNewInstanceTypeFieldNumber = 2;
  inline const ::std::string& new_instance_type() const;
  inline void set_new_instance_type(const ::std::string& value);
  inline void set_new_instance_type(const char* value);
  inline void set_new_instance_type(const char* value, size_t size);
  inline ::std::string* mutable_new_instance_type();
  inline ::std::string* release_new_instance_type();
  
  // optional string lookup_key = 3;
  inline bool has_lookup_key() const;
  inline void clear_lookup_key();
  static const int kLookupKeyFieldNumber = 3;
  inline const ::std::string& lookup_key() const;
  inline void set_lookup_key(const ::std::string& value);
  inline void set_lookup_key(const char* value);
  inline void set_lookup_key(const char* value, size_t size);
  inline ::std::string* mutable_lookup_key();
  inline ::std::string* release_lookup_key();
  
  // optional uint32 lease_instance_id = 4;
  inline bool has_lease_instance_id() const;
  inline void clear_lease_instance_id();
  static const int kLeaseInstanceIdFieldNumber = 4;
  inline ::google::protobuf::uint32 lease_instance_id() const;
  inline void set_lease_instance_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:reef.rpc.Request)
 private:
  inline void set_has_new_instance_type();
  inline void clear_has_new_instance_type();
  inline void set_has_lookup_key();
  inline void clear_has_lookup_key();
  inline void set_has_lease_instance_id();
  inline void clear_has_lease_instance_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* new_instance_type_;
  ::std::string* lookup_key_;
  ::google::protobuf::uint32 lease_instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Invocation : public ::google::protobuf::Message {
 public:
  Invocation();
  virtual ~Invocation();
  
  Invocation(const Invocation& from);
  
  inline Invocation& operator=(const Invocation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Invocation& default_instance();
  
  void Swap(Invocation* other);
  
  // implements Message ----------------------------------------------
  
  Invocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Invocation& from);
  void MergeFrom(const Invocation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 instance_id = 1;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // required uint32 facet_idx = 2;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // required uint32 member_idx = 3;
  inline bool has_member_idx() const;
  inline void clear_member_idx();
  static const int kMemberIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 member_idx() const;
  inline void set_member_idx(::google::protobuf::uint32 value);
  
  // required int32 type_depth = 4;
  inline bool has_type_depth() const;
  inline void clear_type_depth();
  static const int kTypeDepthFieldNumber = 4;
  inline ::google::protobuf::int32 type_depth() const;
  inline void set_type_depth(::google::protobuf::int32 value);
  
  // required bool synch = 5;
  inline bool has_synch() const;
  inline void clear_synch();
  static const int kSynchFieldNumber = 5;
  inline bool synch() const;
  inline void set_synch(bool value);
  
  // repeated .reef.rpc.Parameter params = 6;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 6;
  inline const ::reef::rpc::Parameter& params(int index) const;
  inline ::reef::rpc::Parameter* mutable_params(int index);
  inline ::reef::rpc::Parameter* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >*
      mutable_params();
  
  // @@protoc_insertion_point(class_scope:reef.rpc.Invocation)
 private:
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_member_idx();
  inline void clear_has_member_idx();
  inline void set_has_type_depth();
  inline void clear_has_type_depth();
  inline void set_has_synch();
  inline void clear_has_synch();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 instance_id_;
  ::google::protobuf::uint32 facet_idx_;
  ::google::protobuf::uint32 member_idx_;
  ::google::protobuf::int32 type_depth_;
  ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter > params_;
  bool synch_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Invocation* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();
  
  Parameter(const Parameter& from);
  
  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();
  
  void Swap(Parameter* other);
  
  // implements Message ----------------------------------------------
  
  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .reef.rpc.Any_PB any = 1;
  inline int any_size() const;
  inline void clear_any();
  static const int kAnyFieldNumber = 1;
  inline const ::reef::rpc::Any_PB& any(int index) const;
  inline ::reef::rpc::Any_PB* mutable_any(int index);
  inline ::reef::rpc::Any_PB* add_any();
  inline const ::google::protobuf::RepeatedPtrField< ::reef::rpc::Any_PB >&
      any() const;
  inline ::google::protobuf::RepeatedPtrField< ::reef::rpc::Any_PB >*
      mutable_any();
  
  // optional uint32 any_type = 2;
  inline bool has_any_type() const;
  inline void clear_any_type();
  static const int kAnyTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 any_type() const;
  inline void set_any_type(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:reef.rpc.Parameter)
 private:
  inline void set_has_any_type();
  inline void clear_has_any_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::reef::rpc::Any_PB > any_;
  ::google::protobuf::uint32 any_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Any_PB : public ::google::protobuf::Message {
 public:
  Any_PB();
  virtual ~Any_PB();
  
  Any_PB(const Any_PB& from);
  
  inline Any_PB& operator=(const Any_PB& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Any_PB& default_instance();
  
  void Swap(Any_PB* other);
  
  // implements Message ----------------------------------------------
  
  Any_PB* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Any_PB& from);
  void MergeFrom(const Any_PB& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool boolean = 1;
  inline bool has_boolean() const;
  inline void clear_boolean();
  static const int kBooleanFieldNumber = 1;
  inline bool boolean() const;
  inline void set_boolean(bool value);
  
  // optional string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  
  // optional double numeric = 3;
  inline bool has_numeric() const;
  inline void clear_numeric();
  static const int kNumericFieldNumber = 3;
  inline double numeric() const;
  inline void set_numeric(double value);
  
  // optional .reef.rpc.Complex_Type complex_type = 4;
  inline bool has_complex_type() const;
  inline void clear_complex_type();
  static const int kComplexTypeFieldNumber = 4;
  inline const ::reef::rpc::Complex_Type& complex_type() const;
  inline ::reef::rpc::Complex_Type* mutable_complex_type();
  inline ::reef::rpc::Complex_Type* release_complex_type();
  
  // optional .reef.rpc.Ref_Type ref_type = 5;
  inline bool has_ref_type() const;
  inline void clear_ref_type();
  static const int kRefTypeFieldNumber = 5;
  inline const ::reef::rpc::Ref_Type& ref_type() const;
  inline ::reef::rpc::Ref_Type* mutable_ref_type();
  inline ::reef::rpc::Ref_Type* release_ref_type();
  
  // @@protoc_insertion_point(class_scope:reef.rpc.Any_PB)
 private:
  inline void set_has_boolean();
  inline void clear_has_boolean();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_numeric();
  inline void clear_has_numeric();
  inline void set_has_complex_type();
  inline void clear_has_complex_type();
  inline void set_has_ref_type();
  inline void clear_has_ref_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* str_;
  double numeric_;
  ::reef::rpc::Complex_Type* complex_type_;
  ::reef::rpc::Ref_Type* ref_type_;
  bool boolean_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Any_PB* default_instance_;
};
// -------------------------------------------------------------------

class Complex_Type : public ::google::protobuf::Message {
 public:
  Complex_Type();
  virtual ~Complex_Type();
  
  Complex_Type(const Complex_Type& from);
  
  inline Complex_Type& operator=(const Complex_Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Complex_Type& default_instance();
  
  void Swap(Complex_Type* other);
  
  // implements Message ----------------------------------------------
  
  Complex_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Complex_Type& from);
  void MergeFrom(const Complex_Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .reef.rpc.Parameter field = 1;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::reef::rpc::Parameter& field(int index) const;
  inline ::reef::rpc::Parameter* mutable_field(int index);
  inline ::reef::rpc::Parameter* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >*
      mutable_field();
  
  // @@protoc_insertion_point(class_scope:reef.rpc.Complex_Type)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter > field_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Complex_Type* default_instance_;
};
// -------------------------------------------------------------------

class Ref_Type : public ::google::protobuf::Message {
 public:
  Ref_Type();
  virtual ~Ref_Type();
  
  Ref_Type(const Ref_Type& from);
  
  inline Ref_Type& operator=(const Ref_Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ref_Type& default_instance();
  
  void Swap(Ref_Type* other);
  
  // implements Message ----------------------------------------------
  
  Ref_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ref_Type& from);
  void MergeFrom(const Ref_Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Ref_Type_Owner Owner;
  static const Owner OWNER_SENDER = Ref_Type_Owner_OWNER_SENDER;
  static const Owner OWNER_RECEIVER = Ref_Type_Owner_OWNER_RECEIVER;
  static const Owner OWNER_ANOTHER = Ref_Type_Owner_OWNER_ANOTHER;
  static inline bool Owner_IsValid(int value) {
    return Ref_Type_Owner_IsValid(value);
  }
  static const Owner Owner_MIN =
    Ref_Type_Owner_Owner_MIN;
  static const Owner Owner_MAX =
    Ref_Type_Owner_Owner_MAX;
  static const int Owner_ARRAYSIZE =
    Ref_Type_Owner_Owner_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Owner_descriptor() {
    return Ref_Type_Owner_descriptor();
  }
  static inline const ::std::string& Owner_Name(Owner value) {
    return Ref_Type_Owner_Name(value);
  }
  static inline bool Owner_Parse(const ::std::string& name,
      Owner* value) {
    return Ref_Type_Owner_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .reef.rpc.Ref_Type.Owner owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline ::reef::rpc::Ref_Type_Owner owner() const;
  inline void set_owner(::reef::rpc::Ref_Type_Owner value);
  
  // required uint32 instance_id = 2;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // required uint32 facet_idx = 3;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // optional string instance_type = 4;
  inline bool has_instance_type() const;
  inline void clear_instance_type();
  static const int kInstanceTypeFieldNumber = 4;
  inline const ::std::string& instance_type() const;
  inline void set_instance_type(const ::std::string& value);
  inline void set_instance_type(const char* value);
  inline void set_instance_type(const char* value, size_t size);
  inline ::std::string* mutable_instance_type();
  inline ::std::string* release_instance_type();
  
  // optional string owner_endpoint = 5;
  inline bool has_owner_endpoint() const;
  inline void clear_owner_endpoint();
  static const int kOwnerEndpointFieldNumber = 5;
  inline const ::std::string& owner_endpoint() const;
  inline void set_owner_endpoint(const ::std::string& value);
  inline void set_owner_endpoint(const char* value);
  inline void set_owner_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_owner_endpoint();
  inline ::std::string* release_owner_endpoint();
  
  // @@protoc_insertion_point(class_scope:reef.rpc.Ref_Type)
 private:
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_instance_type();
  inline void clear_has_instance_type();
  inline void set_has_owner_endpoint();
  inline void clear_has_owner_endpoint();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int owner_;
  ::google::protobuf::uint32 instance_id_;
  ::std::string* instance_type_;
  ::std::string* owner_endpoint_;
  ::google::protobuf::uint32 facet_idx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Ref_Type* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// optional string requester_endpoint = 1;
inline bool Message::has_requester_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_requester_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_requester_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_requester_endpoint() {
  if (requester_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_->clear();
  }
  clear_has_requester_endpoint();
}
inline const ::std::string& Message::requester_endpoint() const {
  return *requester_endpoint_;
}
inline void Message::set_requester_endpoint(const ::std::string& value) {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  requester_endpoint_->assign(value);
}
inline void Message::set_requester_endpoint(const char* value) {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  requester_endpoint_->assign(value);
}
inline void Message::set_requester_endpoint(const char* value, size_t size) {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  requester_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_requester_endpoint() {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  return requester_endpoint_;
}
inline ::std::string* Message::release_requester_endpoint() {
  clear_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requester_endpoint_;
    requester_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .reef.rpc.Message.Type type = 2;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::reef::rpc::Message_Type Message::type() const {
  return static_cast< ::reef::rpc::Message_Type >(type_);
}
inline void Message::set_type(::reef::rpc::Message_Type value) {
  GOOGLE_DCHECK(::reef::rpc::Message_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .reef.rpc.Invocation invocation = 3;
inline bool Message::has_invocation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_invocation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_invocation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_invocation() {
  if (invocation_ != NULL) invocation_->::reef::rpc::Invocation::Clear();
  clear_has_invocation();
}
inline const ::reef::rpc::Invocation& Message::invocation() const {
  return invocation_ != NULL ? *invocation_ : *default_instance_->invocation_;
}
inline ::reef::rpc::Invocation* Message::mutable_invocation() {
  set_has_invocation();
  if (invocation_ == NULL) invocation_ = new ::reef::rpc::Invocation;
  return invocation_;
}
inline ::reef::rpc::Invocation* Message::release_invocation() {
  clear_has_invocation();
  ::reef::rpc::Invocation* temp = invocation_;
  invocation_ = NULL;
  return temp;
}

// optional .reef.rpc.Request request = 4;
inline bool Message::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_request() {
  if (request_ != NULL) request_->::reef::rpc::Request::Clear();
  clear_has_request();
}
inline const ::reef::rpc::Request& Message::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::reef::rpc::Request* Message::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::reef::rpc::Request;
  return request_;
}
inline ::reef::rpc::Request* Message::release_request() {
  clear_has_request();
  ::reef::rpc::Request* temp = request_;
  request_ = NULL;
  return temp;
}

// optional .reef.rpc.Parameter ret_value = 5;
inline bool Message::has_ret_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_ret_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_ret_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_ret_value() {
  if (ret_value_ != NULL) ret_value_->::reef::rpc::Parameter::Clear();
  clear_has_ret_value();
}
inline const ::reef::rpc::Parameter& Message::ret_value() const {
  return ret_value_ != NULL ? *ret_value_ : *default_instance_->ret_value_;
}
inline ::reef::rpc::Parameter* Message::mutable_ret_value() {
  set_has_ret_value();
  if (ret_value_ == NULL) ret_value_ = new ::reef::rpc::Parameter;
  return ret_value_;
}
inline ::reef::rpc::Parameter* Message::release_ret_value() {
  clear_has_ret_value();
  ::reef::rpc::Parameter* temp = ret_value_;
  ret_value_ = NULL;
  return temp;
}

// optional int32 ret_int = 6;
inline bool Message::has_ret_int() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_ret_int() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_ret_int() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_ret_int() {
  ret_int_ = 0;
  clear_has_ret_int();
}
inline ::google::protobuf::int32 Message::ret_int() const {
  return ret_int_;
}
inline void Message::set_ret_int(::google::protobuf::int32 value) {
  set_has_ret_int();
  ret_int_ = value;
}

// -------------------------------------------------------------------

// Request

// optional string new_instance_type = 2;
inline bool Request::has_new_instance_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_new_instance_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_new_instance_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_new_instance_type() {
  if (new_instance_type_ != &::google::protobuf::internal::kEmptyString) {
    new_instance_type_->clear();
  }
  clear_has_new_instance_type();
}
inline const ::std::string& Request::new_instance_type() const {
  return *new_instance_type_;
}
inline void Request::set_new_instance_type(const ::std::string& value) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(value);
}
inline void Request::set_new_instance_type(const char* value) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(value);
}
inline void Request::set_new_instance_type(const char* value, size_t size) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_new_instance_type() {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  return new_instance_type_;
}
inline ::std::string* Request::release_new_instance_type() {
  clear_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_instance_type_;
    new_instance_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string lookup_key = 3;
inline bool Request::has_lookup_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_lookup_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_lookup_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_lookup_key() {
  if (lookup_key_ != &::google::protobuf::internal::kEmptyString) {
    lookup_key_->clear();
  }
  clear_has_lookup_key();
}
inline const ::std::string& Request::lookup_key() const {
  return *lookup_key_;
}
inline void Request::set_lookup_key(const ::std::string& value) {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  lookup_key_->assign(value);
}
inline void Request::set_lookup_key(const char* value) {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  lookup_key_->assign(value);
}
inline void Request::set_lookup_key(const char* value, size_t size) {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  lookup_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_lookup_key() {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  return lookup_key_;
}
inline ::std::string* Request::release_lookup_key() {
  clear_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lookup_key_;
    lookup_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 lease_instance_id = 4;
inline bool Request::has_lease_instance_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_lease_instance_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_lease_instance_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_lease_instance_id() {
  lease_instance_id_ = 0u;
  clear_has_lease_instance_id();
}
inline ::google::protobuf::uint32 Request::lease_instance_id() const {
  return lease_instance_id_;
}
inline void Request::set_lease_instance_id(::google::protobuf::uint32 value) {
  set_has_lease_instance_id();
  lease_instance_id_ = value;
}

// -------------------------------------------------------------------

// Invocation

// required uint32 instance_id = 1;
inline bool Invocation::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Invocation::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Invocation::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Invocation::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Invocation::instance_id() const {
  return instance_id_;
}
inline void Invocation::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required uint32 facet_idx = 2;
inline bool Invocation::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Invocation::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Invocation::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Invocation::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Invocation::facet_idx() const {
  return facet_idx_;
}
inline void Invocation::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// required uint32 member_idx = 3;
inline bool Invocation::has_member_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Invocation::set_has_member_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Invocation::clear_has_member_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Invocation::clear_member_idx() {
  member_idx_ = 0u;
  clear_has_member_idx();
}
inline ::google::protobuf::uint32 Invocation::member_idx() const {
  return member_idx_;
}
inline void Invocation::set_member_idx(::google::protobuf::uint32 value) {
  set_has_member_idx();
  member_idx_ = value;
}

// required int32 type_depth = 4;
inline bool Invocation::has_type_depth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Invocation::set_has_type_depth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Invocation::clear_has_type_depth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Invocation::clear_type_depth() {
  type_depth_ = 0;
  clear_has_type_depth();
}
inline ::google::protobuf::int32 Invocation::type_depth() const {
  return type_depth_;
}
inline void Invocation::set_type_depth(::google::protobuf::int32 value) {
  set_has_type_depth();
  type_depth_ = value;
}

// required bool synch = 5;
inline bool Invocation::has_synch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Invocation::set_has_synch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Invocation::clear_has_synch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Invocation::clear_synch() {
  synch_ = false;
  clear_has_synch();
}
inline bool Invocation::synch() const {
  return synch_;
}
inline void Invocation::set_synch(bool value) {
  set_has_synch();
  synch_ = value;
}

// repeated .reef.rpc.Parameter params = 6;
inline int Invocation::params_size() const {
  return params_.size();
}
inline void Invocation::clear_params() {
  params_.Clear();
}
inline const ::reef::rpc::Parameter& Invocation::params(int index) const {
  return params_.Get(index);
}
inline ::reef::rpc::Parameter* Invocation::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::reef::rpc::Parameter* Invocation::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >&
Invocation::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >*
Invocation::mutable_params() {
  return &params_;
}

// -------------------------------------------------------------------

// Parameter

// repeated .reef.rpc.Any_PB any = 1;
inline int Parameter::any_size() const {
  return any_.size();
}
inline void Parameter::clear_any() {
  any_.Clear();
}
inline const ::reef::rpc::Any_PB& Parameter::any(int index) const {
  return any_.Get(index);
}
inline ::reef::rpc::Any_PB* Parameter::mutable_any(int index) {
  return any_.Mutable(index);
}
inline ::reef::rpc::Any_PB* Parameter::add_any() {
  return any_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::reef::rpc::Any_PB >&
Parameter::any() const {
  return any_;
}
inline ::google::protobuf::RepeatedPtrField< ::reef::rpc::Any_PB >*
Parameter::mutable_any() {
  return &any_;
}

// optional uint32 any_type = 2;
inline bool Parameter::has_any_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_any_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_any_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_any_type() {
  any_type_ = 0u;
  clear_has_any_type();
}
inline ::google::protobuf::uint32 Parameter::any_type() const {
  return any_type_;
}
inline void Parameter::set_any_type(::google::protobuf::uint32 value) {
  set_has_any_type();
  any_type_ = value;
}

// -------------------------------------------------------------------

// Any_PB

// optional bool boolean = 1;
inline bool Any_PB::has_boolean() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Any_PB::set_has_boolean() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Any_PB::clear_has_boolean() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Any_PB::clear_boolean() {
  boolean_ = false;
  clear_has_boolean();
}
inline bool Any_PB::boolean() const {
  return boolean_;
}
inline void Any_PB::set_boolean(bool value) {
  set_has_boolean();
  boolean_ = value;
}

// optional string str = 2;
inline bool Any_PB::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Any_PB::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Any_PB::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Any_PB::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Any_PB::str() const {
  return *str_;
}
inline void Any_PB::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Any_PB::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Any_PB::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Any_PB::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Any_PB::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double numeric = 3;
inline bool Any_PB::has_numeric() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Any_PB::set_has_numeric() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Any_PB::clear_has_numeric() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Any_PB::clear_numeric() {
  numeric_ = 0;
  clear_has_numeric();
}
inline double Any_PB::numeric() const {
  return numeric_;
}
inline void Any_PB::set_numeric(double value) {
  set_has_numeric();
  numeric_ = value;
}

// optional .reef.rpc.Complex_Type complex_type = 4;
inline bool Any_PB::has_complex_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Any_PB::set_has_complex_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Any_PB::clear_has_complex_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Any_PB::clear_complex_type() {
  if (complex_type_ != NULL) complex_type_->::reef::rpc::Complex_Type::Clear();
  clear_has_complex_type();
}
inline const ::reef::rpc::Complex_Type& Any_PB::complex_type() const {
  return complex_type_ != NULL ? *complex_type_ : *default_instance_->complex_type_;
}
inline ::reef::rpc::Complex_Type* Any_PB::mutable_complex_type() {
  set_has_complex_type();
  if (complex_type_ == NULL) complex_type_ = new ::reef::rpc::Complex_Type;
  return complex_type_;
}
inline ::reef::rpc::Complex_Type* Any_PB::release_complex_type() {
  clear_has_complex_type();
  ::reef::rpc::Complex_Type* temp = complex_type_;
  complex_type_ = NULL;
  return temp;
}

// optional .reef.rpc.Ref_Type ref_type = 5;
inline bool Any_PB::has_ref_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Any_PB::set_has_ref_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Any_PB::clear_has_ref_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Any_PB::clear_ref_type() {
  if (ref_type_ != NULL) ref_type_->::reef::rpc::Ref_Type::Clear();
  clear_has_ref_type();
}
inline const ::reef::rpc::Ref_Type& Any_PB::ref_type() const {
  return ref_type_ != NULL ? *ref_type_ : *default_instance_->ref_type_;
}
inline ::reef::rpc::Ref_Type* Any_PB::mutable_ref_type() {
  set_has_ref_type();
  if (ref_type_ == NULL) ref_type_ = new ::reef::rpc::Ref_Type;
  return ref_type_;
}
inline ::reef::rpc::Ref_Type* Any_PB::release_ref_type() {
  clear_has_ref_type();
  ::reef::rpc::Ref_Type* temp = ref_type_;
  ref_type_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Complex_Type

// repeated .reef.rpc.Parameter field = 1;
inline int Complex_Type::field_size() const {
  return field_.size();
}
inline void Complex_Type::clear_field() {
  field_.Clear();
}
inline const ::reef::rpc::Parameter& Complex_Type::field(int index) const {
  return field_.Get(index);
}
inline ::reef::rpc::Parameter* Complex_Type::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::reef::rpc::Parameter* Complex_Type::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >&
Complex_Type::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::reef::rpc::Parameter >*
Complex_Type::mutable_field() {
  return &field_;
}

// -------------------------------------------------------------------

// Ref_Type

// required .reef.rpc.Ref_Type.Owner owner = 1;
inline bool Ref_Type::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ref_Type::set_has_owner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ref_Type::clear_has_owner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ref_Type::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::reef::rpc::Ref_Type_Owner Ref_Type::owner() const {
  return static_cast< ::reef::rpc::Ref_Type_Owner >(owner_);
}
inline void Ref_Type::set_owner(::reef::rpc::Ref_Type_Owner value) {
  GOOGLE_DCHECK(::reef::rpc::Ref_Type_Owner_IsValid(value));
  set_has_owner();
  owner_ = value;
}

// required uint32 instance_id = 2;
inline bool Ref_Type::has_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ref_Type::set_has_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ref_Type::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ref_Type::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Ref_Type::instance_id() const {
  return instance_id_;
}
inline void Ref_Type::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required uint32 facet_idx = 3;
inline bool Ref_Type::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ref_Type::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ref_Type::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ref_Type::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Ref_Type::facet_idx() const {
  return facet_idx_;
}
inline void Ref_Type::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// optional string instance_type = 4;
inline bool Ref_Type::has_instance_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ref_Type::set_has_instance_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ref_Type::clear_has_instance_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ref_Type::clear_instance_type() {
  if (instance_type_ != &::google::protobuf::internal::kEmptyString) {
    instance_type_->clear();
  }
  clear_has_instance_type();
}
inline const ::std::string& Ref_Type::instance_type() const {
  return *instance_type_;
}
inline void Ref_Type::set_instance_type(const ::std::string& value) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(value);
}
inline void Ref_Type::set_instance_type(const char* value) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(value);
}
inline void Ref_Type::set_instance_type(const char* value, size_t size) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ref_Type::mutable_instance_type() {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  return instance_type_;
}
inline ::std::string* Ref_Type::release_instance_type() {
  clear_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instance_type_;
    instance_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string owner_endpoint = 5;
inline bool Ref_Type::has_owner_endpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ref_Type::set_has_owner_endpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ref_Type::clear_has_owner_endpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ref_Type::clear_owner_endpoint() {
  if (owner_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_->clear();
  }
  clear_has_owner_endpoint();
}
inline const ::std::string& Ref_Type::owner_endpoint() const {
  return *owner_endpoint_;
}
inline void Ref_Type::set_owner_endpoint(const ::std::string& value) {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  owner_endpoint_->assign(value);
}
inline void Ref_Type::set_owner_endpoint(const char* value) {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  owner_endpoint_->assign(value);
}
inline void Ref_Type::set_owner_endpoint(const char* value, size_t size) {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  owner_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ref_Type::mutable_owner_endpoint() {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  return owner_endpoint_;
}
inline ::std::string* Ref_Type::release_owner_endpoint() {
  clear_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_endpoint_;
    owner_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace reef

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::reef::rpc::Message_Type>() {
  return ::reef::rpc::Message_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::reef::rpc::Ref_Type_Owner>() {
  return ::reef::rpc::Ref_Type_Owner_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
