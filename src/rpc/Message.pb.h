// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class Message;
class Request;
class Exception;
class Invocation;
class Parameter;
class Container;
class Any_Type;
class Complex_Type;
class Ref_Type;

enum Message_Type {
  Message_Type_INVOCATION = 0,
  Message_Type_REQUEST_NEW = 1,
  Message_Type_REQUEST_LOOKUP = 2,
  Message_Type_REQUEST_LEASE = 3,
  Message_Type_REQUEST_CANCEL_LEASE = 4,
  Message_Type_RETURN = 5,
  Message_Type_EXCEPTION = 6,
  Message_Type_BARRIER_UP = 7,
  Message_Type_BARRIER_HIT = 8,
  Message_Type_BARRIER_DOWN = 9
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_INVOCATION;
const Message_Type Message_Type_Type_MAX = Message_Type_BARRIER_DOWN;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum Exception_Type {
  Exception_Type_CORAL = 0,
  Exception_Type_REMOTING = 1,
  Exception_Type_STD = 2
};
bool Exception_Type_IsValid(int value);
const Exception_Type Exception_Type_Type_MIN = Exception_Type_CORAL;
const Exception_Type Exception_Type_Type_MAX = Exception_Type_STD;
const int Exception_Type_Type_ARRAYSIZE = Exception_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Exception_Type_descriptor();
inline const ::std::string& Exception_Type_Name(Exception_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Exception_Type_descriptor(), value);
}
inline bool Exception_Type_Parse(
    const ::std::string& name, Exception_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Exception_Type>(
    Exception_Type_descriptor(), name, value);
}
enum Ref_Type_Owner {
  Ref_Type_Owner_OWNER_SENDER = 0,
  Ref_Type_Owner_OWNER_RECEIVER = 1,
  Ref_Type_Owner_OWNER_ANOTHER = 2
};
bool Ref_Type_Owner_IsValid(int value);
const Ref_Type_Owner Ref_Type_Owner_Owner_MIN = Ref_Type_Owner_OWNER_SENDER;
const Ref_Type_Owner Ref_Type_Owner_Owner_MAX = Ref_Type_Owner_OWNER_ANOTHER;
const int Ref_Type_Owner_Owner_ARRAYSIZE = Ref_Type_Owner_Owner_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ref_Type_Owner_descriptor();
inline const ::std::string& Ref_Type_Owner_Name(Ref_Type_Owner value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ref_Type_Owner_descriptor(), value);
}
inline bool Ref_Type_Owner_Parse(
    const ::std::string& name, Ref_Type_Owner* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ref_Type_Owner>(
    Ref_Type_Owner_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_Type Type;
  static const Type INVOCATION = Message_Type_INVOCATION;
  static const Type REQUEST_NEW = Message_Type_REQUEST_NEW;
  static const Type REQUEST_LOOKUP = Message_Type_REQUEST_LOOKUP;
  static const Type REQUEST_LEASE = Message_Type_REQUEST_LEASE;
  static const Type REQUEST_CANCEL_LEASE = Message_Type_REQUEST_CANCEL_LEASE;
  static const Type RETURN = Message_Type_RETURN;
  static const Type EXCEPTION = Message_Type_EXCEPTION;
  static const Type BARRIER_UP = Message_Type_BARRIER_UP;
  static const Type BARRIER_HIT = Message_Type_BARRIER_HIT;
  static const Type BARRIER_DOWN = Message_Type_BARRIER_DOWN;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string requester_endpoint = 1;
  inline bool has_requester_endpoint() const;
  inline void clear_requester_endpoint();
  static const int kRequesterEndpointFieldNumber = 1;
  inline const ::std::string& requester_endpoint() const;
  inline void set_requester_endpoint(const ::std::string& value);
  inline void set_requester_endpoint(const char* value);
  inline void set_requester_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_requester_endpoint();
  inline ::std::string* release_requester_endpoint();
  
  // required .rpc.Message.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::rpc::Message_Type type() const;
  inline void set_type(::rpc::Message_Type value);
  
  // optional .rpc.Invocation invocation = 3;
  inline bool has_invocation() const;
  inline void clear_invocation();
  static const int kInvocationFieldNumber = 3;
  inline const ::rpc::Invocation& invocation() const;
  inline ::rpc::Invocation* mutable_invocation();
  inline ::rpc::Invocation* release_invocation();
  
  // optional .rpc.Request request = 4;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 4;
  inline const ::rpc::Request& request() const;
  inline ::rpc::Request* mutable_request();
  inline ::rpc::Request* release_request();
  
  // optional .rpc.Parameter ret_value = 5;
  inline bool has_ret_value() const;
  inline void clear_ret_value();
  static const int kRetValueFieldNumber = 5;
  inline const ::rpc::Parameter& ret_value() const;
  inline ::rpc::Parameter* mutable_ret_value();
  inline ::rpc::Parameter* release_ret_value();
  
  // optional int32 ret_int = 6;
  inline bool has_ret_int() const;
  inline void clear_ret_int();
  static const int kRetIntFieldNumber = 6;
  inline ::google::protobuf::int32 ret_int() const;
  inline void set_ret_int(::google::protobuf::int32 value);
  
  // optional .rpc.Exception exception = 7;
  inline bool has_exception() const;
  inline void clear_exception();
  static const int kExceptionFieldNumber = 7;
  inline const ::rpc::Exception& exception() const;
  inline ::rpc::Exception* mutable_exception();
  inline ::rpc::Exception* release_exception();
  
  // @@protoc_insertion_point(class_scope:rpc.Message)
 private:
  inline void set_has_requester_endpoint();
  inline void clear_has_requester_endpoint();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_invocation();
  inline void clear_has_invocation();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_ret_value();
  inline void clear_has_ret_value();
  inline void set_has_ret_int();
  inline void clear_has_ret_int();
  inline void set_has_exception();
  inline void clear_has_exception();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* requester_endpoint_;
  ::rpc::Invocation* invocation_;
  ::rpc::Request* request_;
  int type_;
  ::google::protobuf::int32 ret_int_;
  ::rpc::Parameter* ret_value_;
  ::rpc::Exception* exception_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();
  
  Request(const Request& from);
  
  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();
  
  void Swap(Request* other);
  
  // implements Message ----------------------------------------------
  
  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string new_instance_type = 2;
  inline bool has_new_instance_type() const;
  inline void clear_new_instance_type();
  static const int kNewInstanceTypeFieldNumber = 2;
  inline const ::std::string& new_instance_type() const;
  inline void set_new_instance_type(const ::std::string& value);
  inline void set_new_instance_type(const char* value);
  inline void set_new_instance_type(const char* value, size_t size);
  inline ::std::string* mutable_new_instance_type();
  inline ::std::string* release_new_instance_type();
  
  // optional string lookup_key = 3;
  inline bool has_lookup_key() const;
  inline void clear_lookup_key();
  static const int kLookupKeyFieldNumber = 3;
  inline const ::std::string& lookup_key() const;
  inline void set_lookup_key(const ::std::string& value);
  inline void set_lookup_key(const char* value);
  inline void set_lookup_key(const char* value, size_t size);
  inline ::std::string* mutable_lookup_key();
  inline ::std::string* release_lookup_key();
  
  // optional uint32 lease_instance_id = 4;
  inline bool has_lease_instance_id() const;
  inline void clear_lease_instance_id();
  static const int kLeaseInstanceIdFieldNumber = 4;
  inline ::google::protobuf::uint32 lease_instance_id() const;
  inline void set_lease_instance_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:rpc.Request)
 private:
  inline void set_has_new_instance_type();
  inline void clear_has_new_instance_type();
  inline void set_has_lookup_key();
  inline void clear_has_lookup_key();
  inline void set_has_lease_instance_id();
  inline void clear_has_lease_instance_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* new_instance_type_;
  ::std::string* lookup_key_;
  ::google::protobuf::uint32 lease_instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Exception : public ::google::protobuf::Message {
 public:
  Exception();
  virtual ~Exception();
  
  Exception(const Exception& from);
  
  inline Exception& operator=(const Exception& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Exception& default_instance();
  
  void Swap(Exception* other);
  
  // implements Message ----------------------------------------------
  
  Exception* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exception& from);
  void MergeFrom(const Exception& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Exception_Type Type;
  static const Type CORAL = Exception_Type_CORAL;
  static const Type REMOTING = Exception_Type_REMOTING;
  static const Type STD = Exception_Type_STD;
  static inline bool Type_IsValid(int value) {
    return Exception_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Exception_Type_Type_MIN;
  static const Type Type_MAX =
    Exception_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Exception_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Exception_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Exception_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Exception_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .rpc.Exception.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::rpc::Exception_Type type() const;
  inline void set_type(::rpc::Exception_Type value);
  
  // required string type_name = 2;
  inline bool has_type_name() const;
  inline void clear_type_name();
  static const int kTypeNameFieldNumber = 2;
  inline const ::std::string& type_name() const;
  inline void set_type_name(const ::std::string& value);
  inline void set_type_name(const char* value);
  inline void set_type_name(const char* value, size_t size);
  inline ::std::string* mutable_type_name();
  inline ::std::string* release_type_name();
  
  // required string what = 3;
  inline bool has_what() const;
  inline void clear_what();
  static const int kWhatFieldNumber = 3;
  inline const ::std::string& what() const;
  inline void set_what(const ::std::string& value);
  inline void set_what(const char* value);
  inline void set_what(const char* value, size_t size);
  inline ::std::string* mutable_what();
  inline ::std::string* release_what();
  
  // @@protoc_insertion_point(class_scope:rpc.Exception)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_type_name();
  inline void clear_has_type_name();
  inline void set_has_what();
  inline void clear_has_what();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* type_name_;
  ::std::string* what_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Exception* default_instance_;
};
// -------------------------------------------------------------------

class Invocation : public ::google::protobuf::Message {
 public:
  Invocation();
  virtual ~Invocation();
  
  Invocation(const Invocation& from);
  
  inline Invocation& operator=(const Invocation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Invocation& default_instance();
  
  void Swap(Invocation* other);
  
  // implements Message ----------------------------------------------
  
  Invocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Invocation& from);
  void MergeFrom(const Invocation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 instance_id = 1;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // required uint32 facet_idx = 2;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // required uint32 member_idx = 3;
  inline bool has_member_idx() const;
  inline void clear_member_idx();
  static const int kMemberIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 member_idx() const;
  inline void set_member_idx(::google::protobuf::uint32 value);
  
  // required int32 type_depth = 4;
  inline bool has_type_depth() const;
  inline void clear_type_depth();
  static const int kTypeDepthFieldNumber = 4;
  inline ::google::protobuf::int32 type_depth() const;
  inline void set_type_depth(::google::protobuf::int32 value);
  
  // required bool synch = 5;
  inline bool has_synch() const;
  inline void clear_synch();
  static const int kSynchFieldNumber = 5;
  inline bool synch() const;
  inline void set_synch(bool value);
  
  // repeated .rpc.Parameter params = 6;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 6;
  inline const ::rpc::Parameter& params(int index) const;
  inline ::rpc::Parameter* mutable_params(int index);
  inline ::rpc::Parameter* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >*
      mutable_params();
  
  // @@protoc_insertion_point(class_scope:rpc.Invocation)
 private:
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_member_idx();
  inline void clear_has_member_idx();
  inline void set_has_type_depth();
  inline void clear_has_type_depth();
  inline void set_has_synch();
  inline void clear_has_synch();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 instance_id_;
  ::google::protobuf::uint32 facet_idx_;
  ::google::protobuf::uint32 member_idx_;
  ::google::protobuf::int32 type_depth_;
  ::google::protobuf::RepeatedPtrField< ::rpc::Parameter > params_;
  bool synch_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Invocation* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();
  
  Parameter(const Parameter& from);
  
  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();
  
  void Swap(Parameter* other);
  
  // implements Message ----------------------------------------------
  
  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Container container = 1;
  inline int container_size() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 1;
  inline const ::rpc::Container& container(int index) const;
  inline ::rpc::Container* mutable_container(int index);
  inline ::rpc::Container* add_container();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Container >&
      container() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Container >*
      mutable_container();
  
  // @@protoc_insertion_point(class_scope:rpc.Parameter)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Container > container_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();
  
  Container(const Container& from);
  
  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();
  
  void Swap(Container* other);
  
  // implements Message ----------------------------------------------
  
  Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool boolean = 1;
  inline bool has_boolean() const;
  inline void clear_boolean();
  static const int kBooleanFieldNumber = 1;
  inline bool boolean() const;
  inline void set_boolean(bool value);
  
  // optional string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  
  // optional double numeric = 3;
  inline bool has_numeric() const;
  inline void clear_numeric();
  static const int kNumericFieldNumber = 3;
  inline double numeric() const;
  inline void set_numeric(double value);
  
  // optional .rpc.Complex_Type complex_type = 4;
  inline bool has_complex_type() const;
  inline void clear_complex_type();
  static const int kComplexTypeFieldNumber = 4;
  inline const ::rpc::Complex_Type& complex_type() const;
  inline ::rpc::Complex_Type* mutable_complex_type();
  inline ::rpc::Complex_Type* release_complex_type();
  
  // optional .rpc.Any_Type any_type = 5;
  inline bool has_any_type() const;
  inline void clear_any_type();
  static const int kAnyTypeFieldNumber = 5;
  inline const ::rpc::Any_Type& any_type() const;
  inline ::rpc::Any_Type* mutable_any_type();
  inline ::rpc::Any_Type* release_any_type();
  
  // optional .rpc.Ref_Type ref_type = 6;
  inline bool has_ref_type() const;
  inline void clear_ref_type();
  static const int kRefTypeFieldNumber = 6;
  inline const ::rpc::Ref_Type& ref_type() const;
  inline ::rpc::Ref_Type* mutable_ref_type();
  inline ::rpc::Ref_Type* release_ref_type();
  
  // @@protoc_insertion_point(class_scope:rpc.Container)
 private:
  inline void set_has_boolean();
  inline void clear_has_boolean();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_numeric();
  inline void clear_has_numeric();
  inline void set_has_complex_type();
  inline void clear_has_complex_type();
  inline void set_has_any_type();
  inline void clear_has_any_type();
  inline void set_has_ref_type();
  inline void clear_has_ref_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* str_;
  double numeric_;
  ::rpc::Complex_Type* complex_type_;
  ::rpc::Any_Type* any_type_;
  ::rpc::Ref_Type* ref_type_;
  bool boolean_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// -------------------------------------------------------------------

class Any_Type : public ::google::protobuf::Message {
 public:
  Any_Type();
  virtual ~Any_Type();
  
  Any_Type(const Any_Type& from);
  
  inline Any_Type& operator=(const Any_Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Any_Type& default_instance();
  
  void Swap(Any_Type* other);
  
  // implements Message ----------------------------------------------
  
  Any_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Any_Type& from);
  void MergeFrom(const Any_Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 kind = 1;
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 1;
  inline ::google::protobuf::int32 kind() const;
  inline void set_kind(::google::protobuf::int32 value);
  
  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // optional .rpc.Parameter param = 3;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline const ::rpc::Parameter& param() const;
  inline ::rpc::Parameter* mutable_param();
  inline ::rpc::Parameter* release_param();
  
  // @@protoc_insertion_point(class_scope:rpc.Any_Type)
 private:
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_param();
  inline void clear_has_param();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* type_;
  ::rpc::Parameter* param_;
  ::google::protobuf::int32 kind_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Any_Type* default_instance_;
};
// -------------------------------------------------------------------

class Complex_Type : public ::google::protobuf::Message {
 public:
  Complex_Type();
  virtual ~Complex_Type();
  
  Complex_Type(const Complex_Type& from);
  
  inline Complex_Type& operator=(const Complex_Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Complex_Type& default_instance();
  
  void Swap(Complex_Type* other);
  
  // implements Message ----------------------------------------------
  
  Complex_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Complex_Type& from);
  void MergeFrom(const Complex_Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .rpc.Parameter field = 1;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::rpc::Parameter& field(int index) const;
  inline ::rpc::Parameter* mutable_field(int index);
  inline ::rpc::Parameter* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >*
      mutable_field();
  
  // @@protoc_insertion_point(class_scope:rpc.Complex_Type)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::rpc::Parameter > field_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Complex_Type* default_instance_;
};
// -------------------------------------------------------------------

class Ref_Type : public ::google::protobuf::Message {
 public:
  Ref_Type();
  virtual ~Ref_Type();
  
  Ref_Type(const Ref_Type& from);
  
  inline Ref_Type& operator=(const Ref_Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ref_Type& default_instance();
  
  void Swap(Ref_Type* other);
  
  // implements Message ----------------------------------------------
  
  Ref_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ref_Type& from);
  void MergeFrom(const Ref_Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Ref_Type_Owner Owner;
  static const Owner OWNER_SENDER = Ref_Type_Owner_OWNER_SENDER;
  static const Owner OWNER_RECEIVER = Ref_Type_Owner_OWNER_RECEIVER;
  static const Owner OWNER_ANOTHER = Ref_Type_Owner_OWNER_ANOTHER;
  static inline bool Owner_IsValid(int value) {
    return Ref_Type_Owner_IsValid(value);
  }
  static const Owner Owner_MIN =
    Ref_Type_Owner_Owner_MIN;
  static const Owner Owner_MAX =
    Ref_Type_Owner_Owner_MAX;
  static const int Owner_ARRAYSIZE =
    Ref_Type_Owner_Owner_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Owner_descriptor() {
    return Ref_Type_Owner_descriptor();
  }
  static inline const ::std::string& Owner_Name(Owner value) {
    return Ref_Type_Owner_Name(value);
  }
  static inline bool Owner_Parse(const ::std::string& name,
      Owner* value) {
    return Ref_Type_Owner_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .rpc.Ref_Type.Owner owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline ::rpc::Ref_Type_Owner owner() const;
  inline void set_owner(::rpc::Ref_Type_Owner value);
  
  // required uint32 instance_id = 2;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // required uint32 facet_idx = 3;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // optional string instance_type = 4;
  inline bool has_instance_type() const;
  inline void clear_instance_type();
  static const int kInstanceTypeFieldNumber = 4;
  inline const ::std::string& instance_type() const;
  inline void set_instance_type(const ::std::string& value);
  inline void set_instance_type(const char* value);
  inline void set_instance_type(const char* value, size_t size);
  inline ::std::string* mutable_instance_type();
  inline ::std::string* release_instance_type();
  
  // optional string owner_endpoint = 5;
  inline bool has_owner_endpoint() const;
  inline void clear_owner_endpoint();
  static const int kOwnerEndpointFieldNumber = 5;
  inline const ::std::string& owner_endpoint() const;
  inline void set_owner_endpoint(const ::std::string& value);
  inline void set_owner_endpoint(const char* value);
  inline void set_owner_endpoint(const char* value, size_t size);
  inline ::std::string* mutable_owner_endpoint();
  inline ::std::string* release_owner_endpoint();
  
  // @@protoc_insertion_point(class_scope:rpc.Ref_Type)
 private:
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_instance_type();
  inline void clear_has_instance_type();
  inline void set_has_owner_endpoint();
  inline void clear_has_owner_endpoint();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int owner_;
  ::google::protobuf::uint32 instance_id_;
  ::std::string* instance_type_;
  ::std::string* owner_endpoint_;
  ::google::protobuf::uint32 facet_idx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Ref_Type* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// optional string requester_endpoint = 1;
inline bool Message::has_requester_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_requester_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_requester_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_requester_endpoint() {
  if (requester_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_->clear();
  }
  clear_has_requester_endpoint();
}
inline const ::std::string& Message::requester_endpoint() const {
  return *requester_endpoint_;
}
inline void Message::set_requester_endpoint(const ::std::string& value) {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  requester_endpoint_->assign(value);
}
inline void Message::set_requester_endpoint(const char* value) {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  requester_endpoint_->assign(value);
}
inline void Message::set_requester_endpoint(const char* value, size_t size) {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  requester_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_requester_endpoint() {
  set_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    requester_endpoint_ = new ::std::string;
  }
  return requester_endpoint_;
}
inline ::std::string* Message::release_requester_endpoint() {
  clear_has_requester_endpoint();
  if (requester_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requester_endpoint_;
    requester_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .rpc.Message.Type type = 2;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::rpc::Message_Type Message::type() const {
  return static_cast< ::rpc::Message_Type >(type_);
}
inline void Message::set_type(::rpc::Message_Type value) {
  GOOGLE_DCHECK(::rpc::Message_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .rpc.Invocation invocation = 3;
inline bool Message::has_invocation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_invocation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_invocation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_invocation() {
  if (invocation_ != NULL) invocation_->::rpc::Invocation::Clear();
  clear_has_invocation();
}
inline const ::rpc::Invocation& Message::invocation() const {
  return invocation_ != NULL ? *invocation_ : *default_instance_->invocation_;
}
inline ::rpc::Invocation* Message::mutable_invocation() {
  set_has_invocation();
  if (invocation_ == NULL) invocation_ = new ::rpc::Invocation;
  return invocation_;
}
inline ::rpc::Invocation* Message::release_invocation() {
  clear_has_invocation();
  ::rpc::Invocation* temp = invocation_;
  invocation_ = NULL;
  return temp;
}

// optional .rpc.Request request = 4;
inline bool Message::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_request() {
  if (request_ != NULL) request_->::rpc::Request::Clear();
  clear_has_request();
}
inline const ::rpc::Request& Message::request() const {
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::rpc::Request* Message::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::rpc::Request;
  return request_;
}
inline ::rpc::Request* Message::release_request() {
  clear_has_request();
  ::rpc::Request* temp = request_;
  request_ = NULL;
  return temp;
}

// optional .rpc.Parameter ret_value = 5;
inline bool Message::has_ret_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_ret_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_ret_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_ret_value() {
  if (ret_value_ != NULL) ret_value_->::rpc::Parameter::Clear();
  clear_has_ret_value();
}
inline const ::rpc::Parameter& Message::ret_value() const {
  return ret_value_ != NULL ? *ret_value_ : *default_instance_->ret_value_;
}
inline ::rpc::Parameter* Message::mutable_ret_value() {
  set_has_ret_value();
  if (ret_value_ == NULL) ret_value_ = new ::rpc::Parameter;
  return ret_value_;
}
inline ::rpc::Parameter* Message::release_ret_value() {
  clear_has_ret_value();
  ::rpc::Parameter* temp = ret_value_;
  ret_value_ = NULL;
  return temp;
}

// optional int32 ret_int = 6;
inline bool Message::has_ret_int() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_ret_int() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_ret_int() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_ret_int() {
  ret_int_ = 0;
  clear_has_ret_int();
}
inline ::google::protobuf::int32 Message::ret_int() const {
  return ret_int_;
}
inline void Message::set_ret_int(::google::protobuf::int32 value) {
  set_has_ret_int();
  ret_int_ = value;
}

// optional .rpc.Exception exception = 7;
inline bool Message::has_exception() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_exception() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_exception() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_exception() {
  if (exception_ != NULL) exception_->::rpc::Exception::Clear();
  clear_has_exception();
}
inline const ::rpc::Exception& Message::exception() const {
  return exception_ != NULL ? *exception_ : *default_instance_->exception_;
}
inline ::rpc::Exception* Message::mutable_exception() {
  set_has_exception();
  if (exception_ == NULL) exception_ = new ::rpc::Exception;
  return exception_;
}
inline ::rpc::Exception* Message::release_exception() {
  clear_has_exception();
  ::rpc::Exception* temp = exception_;
  exception_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Request

// optional string new_instance_type = 2;
inline bool Request::has_new_instance_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_new_instance_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_new_instance_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_new_instance_type() {
  if (new_instance_type_ != &::google::protobuf::internal::kEmptyString) {
    new_instance_type_->clear();
  }
  clear_has_new_instance_type();
}
inline const ::std::string& Request::new_instance_type() const {
  return *new_instance_type_;
}
inline void Request::set_new_instance_type(const ::std::string& value) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(value);
}
inline void Request::set_new_instance_type(const char* value) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(value);
}
inline void Request::set_new_instance_type(const char* value, size_t size) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_new_instance_type() {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  return new_instance_type_;
}
inline ::std::string* Request::release_new_instance_type() {
  clear_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_instance_type_;
    new_instance_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string lookup_key = 3;
inline bool Request::has_lookup_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_lookup_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_lookup_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_lookup_key() {
  if (lookup_key_ != &::google::protobuf::internal::kEmptyString) {
    lookup_key_->clear();
  }
  clear_has_lookup_key();
}
inline const ::std::string& Request::lookup_key() const {
  return *lookup_key_;
}
inline void Request::set_lookup_key(const ::std::string& value) {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  lookup_key_->assign(value);
}
inline void Request::set_lookup_key(const char* value) {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  lookup_key_->assign(value);
}
inline void Request::set_lookup_key(const char* value, size_t size) {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  lookup_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Request::mutable_lookup_key() {
  set_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    lookup_key_ = new ::std::string;
  }
  return lookup_key_;
}
inline ::std::string* Request::release_lookup_key() {
  clear_has_lookup_key();
  if (lookup_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lookup_key_;
    lookup_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 lease_instance_id = 4;
inline bool Request::has_lease_instance_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_lease_instance_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_lease_instance_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_lease_instance_id() {
  lease_instance_id_ = 0u;
  clear_has_lease_instance_id();
}
inline ::google::protobuf::uint32 Request::lease_instance_id() const {
  return lease_instance_id_;
}
inline void Request::set_lease_instance_id(::google::protobuf::uint32 value) {
  set_has_lease_instance_id();
  lease_instance_id_ = value;
}

// -------------------------------------------------------------------

// Exception

// required .rpc.Exception.Type type = 1;
inline bool Exception::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exception::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exception::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exception::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::rpc::Exception_Type Exception::type() const {
  return static_cast< ::rpc::Exception_Type >(type_);
}
inline void Exception::set_type(::rpc::Exception_Type value) {
  GOOGLE_DCHECK(::rpc::Exception_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string type_name = 2;
inline bool Exception::has_type_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exception::set_has_type_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exception::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exception::clear_type_name() {
  if (type_name_ != &::google::protobuf::internal::kEmptyString) {
    type_name_->clear();
  }
  clear_has_type_name();
}
inline const ::std::string& Exception::type_name() const {
  return *type_name_;
}
inline void Exception::set_type_name(const ::std::string& value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kEmptyString) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
}
inline void Exception::set_type_name(const char* value) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kEmptyString) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(value);
}
inline void Exception::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kEmptyString) {
    type_name_ = new ::std::string;
  }
  type_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Exception::mutable_type_name() {
  set_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kEmptyString) {
    type_name_ = new ::std::string;
  }
  return type_name_;
}
inline ::std::string* Exception::release_type_name() {
  clear_has_type_name();
  if (type_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_name_;
    type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string what = 3;
inline bool Exception::has_what() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Exception::set_has_what() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Exception::clear_has_what() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Exception::clear_what() {
  if (what_ != &::google::protobuf::internal::kEmptyString) {
    what_->clear();
  }
  clear_has_what();
}
inline const ::std::string& Exception::what() const {
  return *what_;
}
inline void Exception::set_what(const ::std::string& value) {
  set_has_what();
  if (what_ == &::google::protobuf::internal::kEmptyString) {
    what_ = new ::std::string;
  }
  what_->assign(value);
}
inline void Exception::set_what(const char* value) {
  set_has_what();
  if (what_ == &::google::protobuf::internal::kEmptyString) {
    what_ = new ::std::string;
  }
  what_->assign(value);
}
inline void Exception::set_what(const char* value, size_t size) {
  set_has_what();
  if (what_ == &::google::protobuf::internal::kEmptyString) {
    what_ = new ::std::string;
  }
  what_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Exception::mutable_what() {
  set_has_what();
  if (what_ == &::google::protobuf::internal::kEmptyString) {
    what_ = new ::std::string;
  }
  return what_;
}
inline ::std::string* Exception::release_what() {
  clear_has_what();
  if (what_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = what_;
    what_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Invocation

// required uint32 instance_id = 1;
inline bool Invocation::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Invocation::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Invocation::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Invocation::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Invocation::instance_id() const {
  return instance_id_;
}
inline void Invocation::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required uint32 facet_idx = 2;
inline bool Invocation::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Invocation::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Invocation::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Invocation::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Invocation::facet_idx() const {
  return facet_idx_;
}
inline void Invocation::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// required uint32 member_idx = 3;
inline bool Invocation::has_member_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Invocation::set_has_member_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Invocation::clear_has_member_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Invocation::clear_member_idx() {
  member_idx_ = 0u;
  clear_has_member_idx();
}
inline ::google::protobuf::uint32 Invocation::member_idx() const {
  return member_idx_;
}
inline void Invocation::set_member_idx(::google::protobuf::uint32 value) {
  set_has_member_idx();
  member_idx_ = value;
}

// required int32 type_depth = 4;
inline bool Invocation::has_type_depth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Invocation::set_has_type_depth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Invocation::clear_has_type_depth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Invocation::clear_type_depth() {
  type_depth_ = 0;
  clear_has_type_depth();
}
inline ::google::protobuf::int32 Invocation::type_depth() const {
  return type_depth_;
}
inline void Invocation::set_type_depth(::google::protobuf::int32 value) {
  set_has_type_depth();
  type_depth_ = value;
}

// required bool synch = 5;
inline bool Invocation::has_synch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Invocation::set_has_synch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Invocation::clear_has_synch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Invocation::clear_synch() {
  synch_ = false;
  clear_has_synch();
}
inline bool Invocation::synch() const {
  return synch_;
}
inline void Invocation::set_synch(bool value) {
  set_has_synch();
  synch_ = value;
}

// repeated .rpc.Parameter params = 6;
inline int Invocation::params_size() const {
  return params_.size();
}
inline void Invocation::clear_params() {
  params_.Clear();
}
inline const ::rpc::Parameter& Invocation::params(int index) const {
  return params_.Get(index);
}
inline ::rpc::Parameter* Invocation::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::rpc::Parameter* Invocation::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >&
Invocation::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >*
Invocation::mutable_params() {
  return &params_;
}

// -------------------------------------------------------------------

// Parameter

// repeated .rpc.Container container = 1;
inline int Parameter::container_size() const {
  return container_.size();
}
inline void Parameter::clear_container() {
  container_.Clear();
}
inline const ::rpc::Container& Parameter::container(int index) const {
  return container_.Get(index);
}
inline ::rpc::Container* Parameter::mutable_container(int index) {
  return container_.Mutable(index);
}
inline ::rpc::Container* Parameter::add_container() {
  return container_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Container >&
Parameter::container() const {
  return container_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Container >*
Parameter::mutable_container() {
  return &container_;
}

// -------------------------------------------------------------------

// Container

// optional bool boolean = 1;
inline bool Container::has_boolean() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_boolean() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_boolean() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_boolean() {
  boolean_ = false;
  clear_has_boolean();
}
inline bool Container::boolean() const {
  return boolean_;
}
inline void Container::set_boolean(bool value) {
  set_has_boolean();
  boolean_ = value;
}

// optional string str = 2;
inline bool Container::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Container::str() const {
  return *str_;
}
inline void Container::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Container::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Container::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Container::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double numeric = 3;
inline bool Container::has_numeric() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Container::set_has_numeric() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Container::clear_has_numeric() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Container::clear_numeric() {
  numeric_ = 0;
  clear_has_numeric();
}
inline double Container::numeric() const {
  return numeric_;
}
inline void Container::set_numeric(double value) {
  set_has_numeric();
  numeric_ = value;
}

// optional .rpc.Complex_Type complex_type = 4;
inline bool Container::has_complex_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Container::set_has_complex_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Container::clear_has_complex_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Container::clear_complex_type() {
  if (complex_type_ != NULL) complex_type_->::rpc::Complex_Type::Clear();
  clear_has_complex_type();
}
inline const ::rpc::Complex_Type& Container::complex_type() const {
  return complex_type_ != NULL ? *complex_type_ : *default_instance_->complex_type_;
}
inline ::rpc::Complex_Type* Container::mutable_complex_type() {
  set_has_complex_type();
  if (complex_type_ == NULL) complex_type_ = new ::rpc::Complex_Type;
  return complex_type_;
}
inline ::rpc::Complex_Type* Container::release_complex_type() {
  clear_has_complex_type();
  ::rpc::Complex_Type* temp = complex_type_;
  complex_type_ = NULL;
  return temp;
}

// optional .rpc.Any_Type any_type = 5;
inline bool Container::has_any_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Container::set_has_any_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Container::clear_has_any_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Container::clear_any_type() {
  if (any_type_ != NULL) any_type_->::rpc::Any_Type::Clear();
  clear_has_any_type();
}
inline const ::rpc::Any_Type& Container::any_type() const {
  return any_type_ != NULL ? *any_type_ : *default_instance_->any_type_;
}
inline ::rpc::Any_Type* Container::mutable_any_type() {
  set_has_any_type();
  if (any_type_ == NULL) any_type_ = new ::rpc::Any_Type;
  return any_type_;
}
inline ::rpc::Any_Type* Container::release_any_type() {
  clear_has_any_type();
  ::rpc::Any_Type* temp = any_type_;
  any_type_ = NULL;
  return temp;
}

// optional .rpc.Ref_Type ref_type = 6;
inline bool Container::has_ref_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Container::set_has_ref_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Container::clear_has_ref_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Container::clear_ref_type() {
  if (ref_type_ != NULL) ref_type_->::rpc::Ref_Type::Clear();
  clear_has_ref_type();
}
inline const ::rpc::Ref_Type& Container::ref_type() const {
  return ref_type_ != NULL ? *ref_type_ : *default_instance_->ref_type_;
}
inline ::rpc::Ref_Type* Container::mutable_ref_type() {
  set_has_ref_type();
  if (ref_type_ == NULL) ref_type_ = new ::rpc::Ref_Type;
  return ref_type_;
}
inline ::rpc::Ref_Type* Container::release_ref_type() {
  clear_has_ref_type();
  ::rpc::Ref_Type* temp = ref_type_;
  ref_type_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Any_Type

// required int32 kind = 1;
inline bool Any_Type::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Any_Type::set_has_kind() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Any_Type::clear_has_kind() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Any_Type::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::google::protobuf::int32 Any_Type::kind() const {
  return kind_;
}
inline void Any_Type::set_kind(::google::protobuf::int32 value) {
  set_has_kind();
  kind_ = value;
}

// optional string type = 2;
inline bool Any_Type::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Any_Type::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Any_Type::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Any_Type::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Any_Type::type() const {
  return *type_;
}
inline void Any_Type::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Any_Type::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Any_Type::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Any_Type::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* Any_Type::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .rpc.Parameter param = 3;
inline bool Any_Type::has_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Any_Type::set_has_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Any_Type::clear_has_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Any_Type::clear_param() {
  if (param_ != NULL) param_->::rpc::Parameter::Clear();
  clear_has_param();
}
inline const ::rpc::Parameter& Any_Type::param() const {
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::rpc::Parameter* Any_Type::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::rpc::Parameter;
  return param_;
}
inline ::rpc::Parameter* Any_Type::release_param() {
  clear_has_param();
  ::rpc::Parameter* temp = param_;
  param_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Complex_Type

// repeated .rpc.Parameter field = 1;
inline int Complex_Type::field_size() const {
  return field_.size();
}
inline void Complex_Type::clear_field() {
  field_.Clear();
}
inline const ::rpc::Parameter& Complex_Type::field(int index) const {
  return field_.Get(index);
}
inline ::rpc::Parameter* Complex_Type::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::rpc::Parameter* Complex_Type::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >&
Complex_Type::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::rpc::Parameter >*
Complex_Type::mutable_field() {
  return &field_;
}

// -------------------------------------------------------------------

// Ref_Type

// required .rpc.Ref_Type.Owner owner = 1;
inline bool Ref_Type::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ref_Type::set_has_owner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ref_Type::clear_has_owner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ref_Type::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::rpc::Ref_Type_Owner Ref_Type::owner() const {
  return static_cast< ::rpc::Ref_Type_Owner >(owner_);
}
inline void Ref_Type::set_owner(::rpc::Ref_Type_Owner value) {
  GOOGLE_DCHECK(::rpc::Ref_Type_Owner_IsValid(value));
  set_has_owner();
  owner_ = value;
}

// required uint32 instance_id = 2;
inline bool Ref_Type::has_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ref_Type::set_has_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ref_Type::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ref_Type::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Ref_Type::instance_id() const {
  return instance_id_;
}
inline void Ref_Type::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required uint32 facet_idx = 3;
inline bool Ref_Type::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ref_Type::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ref_Type::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ref_Type::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Ref_Type::facet_idx() const {
  return facet_idx_;
}
inline void Ref_Type::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// optional string instance_type = 4;
inline bool Ref_Type::has_instance_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ref_Type::set_has_instance_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ref_Type::clear_has_instance_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ref_Type::clear_instance_type() {
  if (instance_type_ != &::google::protobuf::internal::kEmptyString) {
    instance_type_->clear();
  }
  clear_has_instance_type();
}
inline const ::std::string& Ref_Type::instance_type() const {
  return *instance_type_;
}
inline void Ref_Type::set_instance_type(const ::std::string& value) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(value);
}
inline void Ref_Type::set_instance_type(const char* value) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(value);
}
inline void Ref_Type::set_instance_type(const char* value, size_t size) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ref_Type::mutable_instance_type() {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  return instance_type_;
}
inline ::std::string* Ref_Type::release_instance_type() {
  clear_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instance_type_;
    instance_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string owner_endpoint = 5;
inline bool Ref_Type::has_owner_endpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ref_Type::set_has_owner_endpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ref_Type::clear_has_owner_endpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ref_Type::clear_owner_endpoint() {
  if (owner_endpoint_ != &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_->clear();
  }
  clear_has_owner_endpoint();
}
inline const ::std::string& Ref_Type::owner_endpoint() const {
  return *owner_endpoint_;
}
inline void Ref_Type::set_owner_endpoint(const ::std::string& value) {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  owner_endpoint_->assign(value);
}
inline void Ref_Type::set_owner_endpoint(const char* value) {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  owner_endpoint_->assign(value);
}
inline void Ref_Type::set_owner_endpoint(const char* value, size_t size) {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  owner_endpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ref_Type::mutable_owner_endpoint() {
  set_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    owner_endpoint_ = new ::std::string;
  }
  return owner_endpoint_;
}
inline ::std::string* Ref_Type::release_owner_endpoint() {
  clear_has_owner_endpoint();
  if (owner_endpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_endpoint_;
    owner_endpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rpc::Message_Type>() {
  return ::rpc::Message_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rpc::Exception_Type>() {
  return ::rpc::Exception_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rpc::Ref_Type_Owner>() {
  return ::rpc::Ref_Type_Owner_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
