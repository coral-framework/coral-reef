// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace reef {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class Data_Container;
class Argument;
class Ref_Type;
class Message_Member;
class Message_New_Inst;
class Message_Find_Inst;
class Message_Acc_Inst;
class Message;

enum Ref_Type_Owner {
  Ref_Type_Owner_OWNER_LOCAL = 0,
  Ref_Type_Owner_OWNER_RECEIVER = 1,
  Ref_Type_Owner_OWNER_ANOTHER = 2
};
bool Ref_Type_Owner_IsValid(int value);
const Ref_Type_Owner Ref_Type_Owner_Owner_MIN = Ref_Type_Owner_OWNER_LOCAL;
const Ref_Type_Owner Ref_Type_Owner_Owner_MAX = Ref_Type_Owner_OWNER_ANOTHER;
const int Ref_Type_Owner_Owner_ARRAYSIZE = Ref_Type_Owner_Owner_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ref_Type_Owner_descriptor();
inline const ::std::string& Ref_Type_Owner_Name(Ref_Type_Owner value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ref_Type_Owner_descriptor(), value);
}
inline bool Ref_Type_Owner_Parse(
    const ::std::string& name, Ref_Type_Owner* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ref_Type_Owner>(
    Ref_Type_Owner_descriptor(), name, value);
}
enum Message_Type {
  Message_Type_MSG_NEW_INST = 0,
  Message_Type_MSG_ACCESS_INST = 1,
  Message_Type_MSG_FIND_INST = 2,
  Message_Type_MSG_CALL = 3
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_MSG_NEW_INST;
const Message_Type Message_Type_Type_MAX = Message_Type_MSG_CALL;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
// ===================================================================

class Data_Container : public ::google::protobuf::Message {
 public:
  Data_Container();
  virtual ~Data_Container();
  
  Data_Container(const Data_Container& from);
  
  inline Data_Container& operator=(const Data_Container& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Data_Container& default_instance();
  
  void Swap(Data_Container* other);
  
  // implements Message ----------------------------------------------
  
  Data_Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data_Container& from);
  void MergeFrom(const Data_Container& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool boolean = 1;
  inline bool has_boolean() const;
  inline void clear_boolean();
  static const int kBooleanFieldNumber = 1;
  inline bool boolean() const;
  inline void set_boolean(bool value);
  
  // optional string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  
  // optional double numeric = 3;
  inline bool has_numeric() const;
  inline void clear_numeric();
  static const int kNumericFieldNumber = 3;
  inline double numeric() const;
  inline void set_numeric(double value);
  
  // optional .reef.Ref_Type ref_type = 4;
  inline bool has_ref_type() const;
  inline void clear_ref_type();
  static const int kRefTypeFieldNumber = 4;
  inline const ::reef::Ref_Type& ref_type() const;
  inline ::reef::Ref_Type* mutable_ref_type();
  inline ::reef::Ref_Type* release_ref_type();
  
  // @@protoc_insertion_point(class_scope:reef.Data_Container)
 private:
  inline void set_has_boolean();
  inline void clear_has_boolean();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_numeric();
  inline void clear_has_numeric();
  inline void set_has_ref_type();
  inline void clear_has_ref_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* str_;
  double numeric_;
  ::reef::Ref_Type* ref_type_;
  bool boolean_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Data_Container* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message {
 public:
  Argument();
  virtual ~Argument();
  
  Argument(const Argument& from);
  
  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();
  
  void Swap(Argument* other);
  
  // implements Message ----------------------------------------------
  
  Argument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .reef.Data_Container data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::reef::Data_Container& data(int index) const;
  inline ::reef::Data_Container* mutable_data(int index);
  inline ::reef::Data_Container* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:reef.Argument)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::reef::Data_Container > data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// -------------------------------------------------------------------

class Ref_Type : public ::google::protobuf::Message {
 public:
  Ref_Type();
  virtual ~Ref_Type();
  
  Ref_Type(const Ref_Type& from);
  
  inline Ref_Type& operator=(const Ref_Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ref_Type& default_instance();
  
  void Swap(Ref_Type* other);
  
  // implements Message ----------------------------------------------
  
  Ref_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ref_Type& from);
  void MergeFrom(const Ref_Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Ref_Type_Owner Owner;
  static const Owner OWNER_LOCAL = Ref_Type_Owner_OWNER_LOCAL;
  static const Owner OWNER_RECEIVER = Ref_Type_Owner_OWNER_RECEIVER;
  static const Owner OWNER_ANOTHER = Ref_Type_Owner_OWNER_ANOTHER;
  static inline bool Owner_IsValid(int value) {
    return Ref_Type_Owner_IsValid(value);
  }
  static const Owner Owner_MIN =
    Ref_Type_Owner_Owner_MIN;
  static const Owner Owner_MAX =
    Ref_Type_Owner_Owner_MAX;
  static const int Owner_ARRAYSIZE =
    Ref_Type_Owner_Owner_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Owner_descriptor() {
    return Ref_Type_Owner_descriptor();
  }
  static inline const ::std::string& Owner_Name(Owner value) {
    return Ref_Type_Owner_Name(value);
  }
  static inline bool Owner_Parse(const ::std::string& name,
      Owner* value) {
    return Ref_Type_Owner_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .reef.Ref_Type.Owner owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline ::reef::Ref_Type_Owner owner() const;
  inline void set_owner(::reef::Ref_Type_Owner value);
  
  // required uint32 instance_id = 2;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // required uint32 facet_idx = 3;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // optional string instance_type = 4;
  inline bool has_instance_type() const;
  inline void clear_instance_type();
  static const int kInstanceTypeFieldNumber = 4;
  inline const ::std::string& instance_type() const;
  inline void set_instance_type(const ::std::string& value);
  inline void set_instance_type(const char* value);
  inline void set_instance_type(const char* value, size_t size);
  inline ::std::string* mutable_instance_type();
  inline ::std::string* release_instance_type();
  
  // optional string owner_ip = 5;
  inline bool has_owner_ip() const;
  inline void clear_owner_ip();
  static const int kOwnerIpFieldNumber = 5;
  inline const ::std::string& owner_ip() const;
  inline void set_owner_ip(const ::std::string& value);
  inline void set_owner_ip(const char* value);
  inline void set_owner_ip(const char* value, size_t size);
  inline ::std::string* mutable_owner_ip();
  inline ::std::string* release_owner_ip();
  
  // @@protoc_insertion_point(class_scope:reef.Ref_Type)
 private:
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_instance_type();
  inline void clear_has_instance_type();
  inline void set_has_owner_ip();
  inline void clear_has_owner_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int owner_;
  ::google::protobuf::uint32 instance_id_;
  ::std::string* instance_type_;
  ::std::string* owner_ip_;
  ::google::protobuf::uint32 facet_idx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Ref_Type* default_instance_;
};
// -------------------------------------------------------------------

class Message_Member : public ::google::protobuf::Message {
 public:
  Message_Member();
  virtual ~Message_Member();
  
  Message_Member(const Message_Member& from);
  
  inline Message_Member& operator=(const Message_Member& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Member& default_instance();
  
  void Swap(Message_Member* other);
  
  // implements Message ----------------------------------------------
  
  Message_Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Member& from);
  void MergeFrom(const Message_Member& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 facet_idx = 1;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // required uint32 member_idx = 2;
  inline bool has_member_idx() const;
  inline void clear_member_idx();
  static const int kMemberIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 member_idx() const;
  inline void set_member_idx(::google::protobuf::uint32 value);
  
  // repeated .reef.Argument arguments = 4;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 4;
  inline const ::reef::Argument& arguments(int index) const;
  inline ::reef::Argument* mutable_arguments(int index);
  inline ::reef::Argument* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::reef::Argument >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::reef::Argument >*
      mutable_arguments();
  
  // @@protoc_insertion_point(class_scope:reef.Message_Member)
 private:
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_member_idx();
  inline void clear_has_member_idx();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 facet_idx_;
  ::google::protobuf::uint32 member_idx_;
  ::google::protobuf::RepeatedPtrField< ::reef::Argument > arguments_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message_Member* default_instance_;
};
// -------------------------------------------------------------------

class Message_New_Inst : public ::google::protobuf::Message {
 public:
  Message_New_Inst();
  virtual ~Message_New_Inst();
  
  Message_New_Inst(const Message_New_Inst& from);
  
  inline Message_New_Inst& operator=(const Message_New_Inst& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_New_Inst& default_instance();
  
  void Swap(Message_New_Inst* other);
  
  // implements Message ----------------------------------------------
  
  Message_New_Inst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_New_Inst& from);
  void MergeFrom(const Message_New_Inst& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string new_instance_type = 1;
  inline bool has_new_instance_type() const;
  inline void clear_new_instance_type();
  static const int kNewInstanceTypeFieldNumber = 1;
  inline const ::std::string& new_instance_type() const;
  inline void set_new_instance_type(const ::std::string& value);
  inline void set_new_instance_type(const char* value);
  inline void set_new_instance_type(const char* value, size_t size);
  inline ::std::string* mutable_new_instance_type();
  inline ::std::string* release_new_instance_type();
  
  // @@protoc_insertion_point(class_scope:reef.Message_New_Inst)
 private:
  inline void set_has_new_instance_type();
  inline void clear_has_new_instance_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* new_instance_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message_New_Inst* default_instance_;
};
// -------------------------------------------------------------------

class Message_Find_Inst : public ::google::protobuf::Message {
 public:
  Message_Find_Inst();
  virtual ~Message_Find_Inst();
  
  Message_Find_Inst(const Message_Find_Inst& from);
  
  inline Message_Find_Inst& operator=(const Message_Find_Inst& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Find_Inst& default_instance();
  
  void Swap(Message_Find_Inst* other);
  
  // implements Message ----------------------------------------------
  
  Message_Find_Inst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Find_Inst& from);
  void MergeFrom(const Message_Find_Inst& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // @@protoc_insertion_point(class_scope:reef.Message_Find_Inst)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message_Find_Inst* default_instance_;
};
// -------------------------------------------------------------------

class Message_Acc_Inst : public ::google::protobuf::Message {
 public:
  Message_Acc_Inst();
  virtual ~Message_Acc_Inst();
  
  Message_Acc_Inst(const Message_Acc_Inst& from);
  
  inline Message_Acc_Inst& operator=(const Message_Acc_Inst& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Acc_Inst& default_instance();
  
  void Swap(Message_Acc_Inst* other);
  
  // implements Message ----------------------------------------------
  
  Message_Acc_Inst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Acc_Inst& from);
  void MergeFrom(const Message_Acc_Inst& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool increment = 1;
  inline bool has_increment() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 1;
  inline bool increment() const;
  inline void set_increment(bool value);
  
  // required uint32 instance_id = 2;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:reef.Message_Acc_Inst)
 private:
  inline void set_has_increment();
  inline void clear_has_increment();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool increment_;
  ::google::protobuf::uint32 instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message_Acc_Inst* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Message_Type Type;
  static const Type MSG_NEW_INST = Message_Type_MSG_NEW_INST;
  static const Type MSG_ACCESS_INST = Message_Type_MSG_ACCESS_INST;
  static const Type MSG_FIND_INST = Message_Type_MSG_FIND_INST;
  static const Type MSG_CALL = Message_Type_MSG_CALL;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .reef.Message.Type msg_type = 1;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  inline ::reef::Message_Type msg_type() const;
  inline void set_msg_type(::reef::Message_Type value);
  
  // required uint32 instance_id = 2;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // required bool has_return = 3;
  inline bool has_has_return() const;
  inline void clear_has_return();
  static const int kHasReturnFieldNumber = 3;
  inline bool has_return() const;
  inline void set_has_return(bool value);
  
  // optional .reef.Message_New_Inst msg_new_inst = 4;
  inline bool has_msg_new_inst() const;
  inline void clear_msg_new_inst();
  static const int kMsgNewInstFieldNumber = 4;
  inline const ::reef::Message_New_Inst& msg_new_inst() const;
  inline ::reef::Message_New_Inst* mutable_msg_new_inst();
  inline ::reef::Message_New_Inst* release_msg_new_inst();
  
  // optional .reef.Message_Acc_Inst msg_acc_inst = 5;
  inline bool has_msg_acc_inst() const;
  inline void clear_msg_acc_inst();
  static const int kMsgAccInstFieldNumber = 5;
  inline const ::reef::Message_Acc_Inst& msg_acc_inst() const;
  inline ::reef::Message_Acc_Inst* mutable_msg_acc_inst();
  inline ::reef::Message_Acc_Inst* release_msg_acc_inst();
  
  // optional .reef.Message_Find_Inst msg_find_inst = 6;
  inline bool has_msg_find_inst() const;
  inline void clear_msg_find_inst();
  static const int kMsgFindInstFieldNumber = 6;
  inline const ::reef::Message_Find_Inst& msg_find_inst() const;
  inline ::reef::Message_Find_Inst* mutable_msg_find_inst();
  inline ::reef::Message_Find_Inst* release_msg_find_inst();
  
  // optional .reef.Message_Member msg_member = 7;
  inline bool has_msg_member() const;
  inline void clear_msg_member();
  static const int kMsgMemberFieldNumber = 7;
  inline const ::reef::Message_Member& msg_member() const;
  inline ::reef::Message_Member* mutable_msg_member();
  inline ::reef::Message_Member* release_msg_member();
  
  // @@protoc_insertion_point(class_scope:reef.Message)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_has_return();
  inline void clear_has_has_return();
  inline void set_has_msg_new_inst();
  inline void clear_has_msg_new_inst();
  inline void set_has_msg_acc_inst();
  inline void clear_has_msg_acc_inst();
  inline void set_has_msg_find_inst();
  inline void clear_has_msg_find_inst();
  inline void set_has_msg_member();
  inline void clear_has_msg_member();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int msg_type_;
  ::google::protobuf::uint32 instance_id_;
  ::reef::Message_New_Inst* msg_new_inst_;
  ::reef::Message_Acc_Inst* msg_acc_inst_;
  ::reef::Message_Find_Inst* msg_find_inst_;
  ::reef::Message_Member* msg_member_;
  bool has_return_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Data_Container

// optional bool boolean = 1;
inline bool Data_Container::has_boolean() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data_Container::set_has_boolean() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data_Container::clear_has_boolean() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data_Container::clear_boolean() {
  boolean_ = false;
  clear_has_boolean();
}
inline bool Data_Container::boolean() const {
  return boolean_;
}
inline void Data_Container::set_boolean(bool value) {
  set_has_boolean();
  boolean_ = value;
}

// optional string str = 2;
inline bool Data_Container::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data_Container::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data_Container::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data_Container::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Data_Container::str() const {
  return *str_;
}
inline void Data_Container::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Data_Container::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Data_Container::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Data_Container::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Data_Container::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double numeric = 3;
inline bool Data_Container::has_numeric() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Data_Container::set_has_numeric() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Data_Container::clear_has_numeric() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Data_Container::clear_numeric() {
  numeric_ = 0;
  clear_has_numeric();
}
inline double Data_Container::numeric() const {
  return numeric_;
}
inline void Data_Container::set_numeric(double value) {
  set_has_numeric();
  numeric_ = value;
}

// optional .reef.Ref_Type ref_type = 4;
inline bool Data_Container::has_ref_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Data_Container::set_has_ref_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Data_Container::clear_has_ref_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Data_Container::clear_ref_type() {
  if (ref_type_ != NULL) ref_type_->::reef::Ref_Type::Clear();
  clear_has_ref_type();
}
inline const ::reef::Ref_Type& Data_Container::ref_type() const {
  return ref_type_ != NULL ? *ref_type_ : *default_instance_->ref_type_;
}
inline ::reef::Ref_Type* Data_Container::mutable_ref_type() {
  set_has_ref_type();
  if (ref_type_ == NULL) ref_type_ = new ::reef::Ref_Type;
  return ref_type_;
}
inline ::reef::Ref_Type* Data_Container::release_ref_type() {
  clear_has_ref_type();
  ::reef::Ref_Type* temp = ref_type_;
  ref_type_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Argument

// repeated .reef.Data_Container data = 1;
inline int Argument::data_size() const {
  return data_.size();
}
inline void Argument::clear_data() {
  data_.Clear();
}
inline const ::reef::Data_Container& Argument::data(int index) const {
  return data_.Get(index);
}
inline ::reef::Data_Container* Argument::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::reef::Data_Container* Argument::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >&
Argument::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >*
Argument::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// Ref_Type

// required .reef.Ref_Type.Owner owner = 1;
inline bool Ref_Type::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ref_Type::set_has_owner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ref_Type::clear_has_owner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ref_Type::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::reef::Ref_Type_Owner Ref_Type::owner() const {
  return static_cast< ::reef::Ref_Type_Owner >(owner_);
}
inline void Ref_Type::set_owner(::reef::Ref_Type_Owner value) {
  GOOGLE_DCHECK(::reef::Ref_Type_Owner_IsValid(value));
  set_has_owner();
  owner_ = value;
}

// required uint32 instance_id = 2;
inline bool Ref_Type::has_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ref_Type::set_has_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ref_Type::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ref_Type::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Ref_Type::instance_id() const {
  return instance_id_;
}
inline void Ref_Type::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required uint32 facet_idx = 3;
inline bool Ref_Type::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ref_Type::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ref_Type::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ref_Type::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Ref_Type::facet_idx() const {
  return facet_idx_;
}
inline void Ref_Type::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// optional string instance_type = 4;
inline bool Ref_Type::has_instance_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ref_Type::set_has_instance_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ref_Type::clear_has_instance_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ref_Type::clear_instance_type() {
  if (instance_type_ != &::google::protobuf::internal::kEmptyString) {
    instance_type_->clear();
  }
  clear_has_instance_type();
}
inline const ::std::string& Ref_Type::instance_type() const {
  return *instance_type_;
}
inline void Ref_Type::set_instance_type(const ::std::string& value) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(value);
}
inline void Ref_Type::set_instance_type(const char* value) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(value);
}
inline void Ref_Type::set_instance_type(const char* value, size_t size) {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  instance_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ref_Type::mutable_instance_type() {
  set_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    instance_type_ = new ::std::string;
  }
  return instance_type_;
}
inline ::std::string* Ref_Type::release_instance_type() {
  clear_has_instance_type();
  if (instance_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instance_type_;
    instance_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string owner_ip = 5;
inline bool Ref_Type::has_owner_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ref_Type::set_has_owner_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ref_Type::clear_has_owner_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ref_Type::clear_owner_ip() {
  if (owner_ip_ != &::google::protobuf::internal::kEmptyString) {
    owner_ip_->clear();
  }
  clear_has_owner_ip();
}
inline const ::std::string& Ref_Type::owner_ip() const {
  return *owner_ip_;
}
inline void Ref_Type::set_owner_ip(const ::std::string& value) {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  owner_ip_->assign(value);
}
inline void Ref_Type::set_owner_ip(const char* value) {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  owner_ip_->assign(value);
}
inline void Ref_Type::set_owner_ip(const char* value, size_t size) {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  owner_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ref_Type::mutable_owner_ip() {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  return owner_ip_;
}
inline ::std::string* Ref_Type::release_owner_ip() {
  clear_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_ip_;
    owner_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Message_Member

// required uint32 facet_idx = 1;
inline bool Message_Member::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Member::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Member::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Member::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Message_Member::facet_idx() const {
  return facet_idx_;
}
inline void Message_Member::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// required uint32 member_idx = 2;
inline bool Message_Member::has_member_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Member::set_has_member_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Member::clear_has_member_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Member::clear_member_idx() {
  member_idx_ = 0u;
  clear_has_member_idx();
}
inline ::google::protobuf::uint32 Message_Member::member_idx() const {
  return member_idx_;
}
inline void Message_Member::set_member_idx(::google::protobuf::uint32 value) {
  set_has_member_idx();
  member_idx_ = value;
}

// repeated .reef.Argument arguments = 4;
inline int Message_Member::arguments_size() const {
  return arguments_.size();
}
inline void Message_Member::clear_arguments() {
  arguments_.Clear();
}
inline const ::reef::Argument& Message_Member::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::reef::Argument* Message_Member::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::reef::Argument* Message_Member::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::reef::Argument >&
Message_Member::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::reef::Argument >*
Message_Member::mutable_arguments() {
  return &arguments_;
}

// -------------------------------------------------------------------

// Message_New_Inst

// optional string new_instance_type = 1;
inline bool Message_New_Inst::has_new_instance_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_New_Inst::set_has_new_instance_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_New_Inst::clear_has_new_instance_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_New_Inst::clear_new_instance_type() {
  if (new_instance_type_ != &::google::protobuf::internal::kEmptyString) {
    new_instance_type_->clear();
  }
  clear_has_new_instance_type();
}
inline const ::std::string& Message_New_Inst::new_instance_type() const {
  return *new_instance_type_;
}
inline void Message_New_Inst::set_new_instance_type(const ::std::string& value) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(value);
}
inline void Message_New_Inst::set_new_instance_type(const char* value) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(value);
}
inline void Message_New_Inst::set_new_instance_type(const char* value, size_t size) {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  new_instance_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_New_Inst::mutable_new_instance_type() {
  set_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    new_instance_type_ = new ::std::string;
  }
  return new_instance_type_;
}
inline ::std::string* Message_New_Inst::release_new_instance_type() {
  clear_has_new_instance_type();
  if (new_instance_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_instance_type_;
    new_instance_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Message_Find_Inst

// optional string key = 1;
inline bool Message_Find_Inst::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Find_Inst::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Find_Inst::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Find_Inst::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Message_Find_Inst::key() const {
  return *key_;
}
inline void Message_Find_Inst::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Message_Find_Inst::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Message_Find_Inst::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_Find_Inst::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Message_Find_Inst::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Message_Acc_Inst

// required bool increment = 1;
inline bool Message_Acc_Inst::has_increment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Acc_Inst::set_has_increment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Acc_Inst::clear_has_increment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Acc_Inst::clear_increment() {
  increment_ = false;
  clear_has_increment();
}
inline bool Message_Acc_Inst::increment() const {
  return increment_;
}
inline void Message_Acc_Inst::set_increment(bool value) {
  set_has_increment();
  increment_ = value;
}

// required uint32 instance_id = 2;
inline bool Message_Acc_Inst::has_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Acc_Inst::set_has_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Acc_Inst::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Acc_Inst::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Message_Acc_Inst::instance_id() const {
  return instance_id_;
}
inline void Message_Acc_Inst::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// -------------------------------------------------------------------

// Message

// required .reef.Message.Type msg_type = 1;
inline bool Message::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_msg_type() {
  msg_type_ = 0;
  clear_has_msg_type();
}
inline ::reef::Message_Type Message::msg_type() const {
  return static_cast< ::reef::Message_Type >(msg_type_);
}
inline void Message::set_msg_type(::reef::Message_Type value) {
  GOOGLE_DCHECK(::reef::Message_Type_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
}

// required uint32 instance_id = 2;
inline bool Message::has_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Message::instance_id() const {
  return instance_id_;
}
inline void Message::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required bool has_return = 3;
inline bool Message::has_has_return() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_has_return() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_has_return() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_has_return() {
  has_return_ = false;
  clear_has_has_return();
}
inline bool Message::has_return() const {
  return has_return_;
}
inline void Message::set_has_return(bool value) {
  set_has_has_return();
  has_return_ = value;
}

// optional .reef.Message_New_Inst msg_new_inst = 4;
inline bool Message::has_msg_new_inst() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_msg_new_inst() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_msg_new_inst() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_msg_new_inst() {
  if (msg_new_inst_ != NULL) msg_new_inst_->::reef::Message_New_Inst::Clear();
  clear_has_msg_new_inst();
}
inline const ::reef::Message_New_Inst& Message::msg_new_inst() const {
  return msg_new_inst_ != NULL ? *msg_new_inst_ : *default_instance_->msg_new_inst_;
}
inline ::reef::Message_New_Inst* Message::mutable_msg_new_inst() {
  set_has_msg_new_inst();
  if (msg_new_inst_ == NULL) msg_new_inst_ = new ::reef::Message_New_Inst;
  return msg_new_inst_;
}
inline ::reef::Message_New_Inst* Message::release_msg_new_inst() {
  clear_has_msg_new_inst();
  ::reef::Message_New_Inst* temp = msg_new_inst_;
  msg_new_inst_ = NULL;
  return temp;
}

// optional .reef.Message_Acc_Inst msg_acc_inst = 5;
inline bool Message::has_msg_acc_inst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_msg_acc_inst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_msg_acc_inst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_msg_acc_inst() {
  if (msg_acc_inst_ != NULL) msg_acc_inst_->::reef::Message_Acc_Inst::Clear();
  clear_has_msg_acc_inst();
}
inline const ::reef::Message_Acc_Inst& Message::msg_acc_inst() const {
  return msg_acc_inst_ != NULL ? *msg_acc_inst_ : *default_instance_->msg_acc_inst_;
}
inline ::reef::Message_Acc_Inst* Message::mutable_msg_acc_inst() {
  set_has_msg_acc_inst();
  if (msg_acc_inst_ == NULL) msg_acc_inst_ = new ::reef::Message_Acc_Inst;
  return msg_acc_inst_;
}
inline ::reef::Message_Acc_Inst* Message::release_msg_acc_inst() {
  clear_has_msg_acc_inst();
  ::reef::Message_Acc_Inst* temp = msg_acc_inst_;
  msg_acc_inst_ = NULL;
  return temp;
}

// optional .reef.Message_Find_Inst msg_find_inst = 6;
inline bool Message::has_msg_find_inst() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_msg_find_inst() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_msg_find_inst() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_msg_find_inst() {
  if (msg_find_inst_ != NULL) msg_find_inst_->::reef::Message_Find_Inst::Clear();
  clear_has_msg_find_inst();
}
inline const ::reef::Message_Find_Inst& Message::msg_find_inst() const {
  return msg_find_inst_ != NULL ? *msg_find_inst_ : *default_instance_->msg_find_inst_;
}
inline ::reef::Message_Find_Inst* Message::mutable_msg_find_inst() {
  set_has_msg_find_inst();
  if (msg_find_inst_ == NULL) msg_find_inst_ = new ::reef::Message_Find_Inst;
  return msg_find_inst_;
}
inline ::reef::Message_Find_Inst* Message::release_msg_find_inst() {
  clear_has_msg_find_inst();
  ::reef::Message_Find_Inst* temp = msg_find_inst_;
  msg_find_inst_ = NULL;
  return temp;
}

// optional .reef.Message_Member msg_member = 7;
inline bool Message::has_msg_member() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_msg_member() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_msg_member() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_msg_member() {
  if (msg_member_ != NULL) msg_member_->::reef::Message_Member::Clear();
  clear_has_msg_member();
}
inline const ::reef::Message_Member& Message::msg_member() const {
  return msg_member_ != NULL ? *msg_member_ : *default_instance_->msg_member_;
}
inline ::reef::Message_Member* Message::mutable_msg_member() {
  set_has_msg_member();
  if (msg_member_ == NULL) msg_member_ = new ::reef::Message_Member;
  return msg_member_;
}
inline ::reef::Message_Member* Message::release_msg_member() {
  clear_has_msg_member();
  ::reef::Message_Member* temp = msg_member_;
  msg_member_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace reef

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::reef::Ref_Type_Owner>() {
  return ::reef::Ref_Type_Owner_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::reef::Message_Type>() {
  return ::reef::Message_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
