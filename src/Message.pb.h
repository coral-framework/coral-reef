// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_Message_2eproto__INCLUDED
#define PROTOBUF_Message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace reef {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Message_2eproto();
void protobuf_AssignDesc_Message_2eproto();
void protobuf_ShutdownFile_Message_2eproto();

class Data_Container;
class Argument;
class Ref_Type;
class Message_Member;
class Message_New;
class Message;

enum Ref_Type_Owner {
  Ref_Type_Owner_OWNER_LOCAL = 0,
  Ref_Type_Owner_OWNER_RECEIVER = 1,
  Ref_Type_Owner_OWNER_ANOTHER = 2
};
bool Ref_Type_Owner_IsValid(int value);
const Ref_Type_Owner Ref_Type_Owner_Owner_MIN = Ref_Type_Owner_OWNER_LOCAL;
const Ref_Type_Owner Ref_Type_Owner_Owner_MAX = Ref_Type_Owner_OWNER_ANOTHER;
const int Ref_Type_Owner_Owner_ARRAYSIZE = Ref_Type_Owner_Owner_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ref_Type_Owner_descriptor();
inline const ::std::string& Ref_Type_Owner_Name(Ref_Type_Owner value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ref_Type_Owner_descriptor(), value);
}
inline bool Ref_Type_Owner_Parse(
    const ::std::string& name, Ref_Type_Owner* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ref_Type_Owner>(
    Ref_Type_Owner_descriptor(), name, value);
}
// ===================================================================

class Data_Container : public ::google::protobuf::Message {
 public:
  Data_Container();
  virtual ~Data_Container();
  
  Data_Container(const Data_Container& from);
  
  inline Data_Container& operator=(const Data_Container& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Data_Container& default_instance();
  
  void Swap(Data_Container* other);
  
  // implements Message ----------------------------------------------
  
  Data_Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data_Container& from);
  void MergeFrom(const Data_Container& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool boolean = 1;
  inline bool has_boolean() const;
  inline void clear_boolean();
  static const int kBooleanFieldNumber = 1;
  inline bool boolean() const;
  inline void set_boolean(bool value);
  
  // optional string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  
  // optional double numeric = 3;
  inline bool has_numeric() const;
  inline void clear_numeric();
  static const int kNumericFieldNumber = 3;
  inline double numeric() const;
  inline void set_numeric(double value);
  
  // optional .reef.Ref_Type ref_type = 4;
  inline bool has_ref_type() const;
  inline void clear_ref_type();
  static const int kRefTypeFieldNumber = 4;
  inline const ::reef::Ref_Type& ref_type() const;
  inline ::reef::Ref_Type* mutable_ref_type();
  inline ::reef::Ref_Type* release_ref_type();
  
  // @@protoc_insertion_point(class_scope:reef.Data_Container)
 private:
  inline void set_has_boolean();
  inline void clear_has_boolean();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_numeric();
  inline void clear_has_numeric();
  inline void set_has_ref_type();
  inline void clear_has_ref_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* str_;
  double numeric_;
  ::reef::Ref_Type* ref_type_;
  bool boolean_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Data_Container* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message {
 public:
  Argument();
  virtual ~Argument();
  
  Argument(const Argument& from);
  
  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();
  
  void Swap(Argument* other);
  
  // implements Message ----------------------------------------------
  
  Argument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .reef.Data_Container data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::reef::Data_Container& data(int index) const;
  inline ::reef::Data_Container* mutable_data(int index);
  inline ::reef::Data_Container* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:reef.Argument)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::reef::Data_Container > data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// -------------------------------------------------------------------

class Ref_Type : public ::google::protobuf::Message {
 public:
  Ref_Type();
  virtual ~Ref_Type();
  
  Ref_Type(const Ref_Type& from);
  
  inline Ref_Type& operator=(const Ref_Type& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ref_Type& default_instance();
  
  void Swap(Ref_Type* other);
  
  // implements Message ----------------------------------------------
  
  Ref_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ref_Type& from);
  void MergeFrom(const Ref_Type& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Ref_Type_Owner Owner;
  static const Owner OWNER_LOCAL = Ref_Type_Owner_OWNER_LOCAL;
  static const Owner OWNER_RECEIVER = Ref_Type_Owner_OWNER_RECEIVER;
  static const Owner OWNER_ANOTHER = Ref_Type_Owner_OWNER_ANOTHER;
  static inline bool Owner_IsValid(int value) {
    return Ref_Type_Owner_IsValid(value);
  }
  static const Owner Owner_MIN =
    Ref_Type_Owner_Owner_MIN;
  static const Owner Owner_MAX =
    Ref_Type_Owner_Owner_MAX;
  static const int Owner_ARRAYSIZE =
    Ref_Type_Owner_Owner_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Owner_descriptor() {
    return Ref_Type_Owner_descriptor();
  }
  static inline const ::std::string& Owner_Name(Owner value) {
    return Ref_Type_Owner_Name(value);
  }
  static inline bool Owner_Parse(const ::std::string& name,
      Owner* value) {
    return Ref_Type_Owner_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .reef.Ref_Type.Owner owner = 1;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 1;
  inline ::reef::Ref_Type_Owner owner() const;
  inline void set_owner(::reef::Ref_Type_Owner value);
  
  // required uint32 instance_id = 2;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 2;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // required uint32 facet_idx = 3;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // optional string owner_ip = 4;
  inline bool has_owner_ip() const;
  inline void clear_owner_ip();
  static const int kOwnerIpFieldNumber = 4;
  inline const ::std::string& owner_ip() const;
  inline void set_owner_ip(const ::std::string& value);
  inline void set_owner_ip(const char* value);
  inline void set_owner_ip(const char* value, size_t size);
  inline ::std::string* mutable_owner_ip();
  inline ::std::string* release_owner_ip();
  
  // @@protoc_insertion_point(class_scope:reef.Ref_Type)
 private:
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_owner_ip();
  inline void clear_has_owner_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int owner_;
  ::google::protobuf::uint32 instance_id_;
  ::std::string* owner_ip_;
  ::google::protobuf::uint32 facet_idx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Ref_Type* default_instance_;
};
// -------------------------------------------------------------------

class Message_Member : public ::google::protobuf::Message {
 public:
  Message_Member();
  virtual ~Message_Member();
  
  Message_Member(const Message_Member& from);
  
  inline Message_Member& operator=(const Message_Member& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Member& default_instance();
  
  void Swap(Message_Member* other);
  
  // implements Message ----------------------------------------------
  
  Message_Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Member& from);
  void MergeFrom(const Message_Member& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 facet_idx = 1;
  inline bool has_facet_idx() const;
  inline void clear_facet_idx();
  static const int kFacetIdxFieldNumber = 1;
  inline ::google::protobuf::uint32 facet_idx() const;
  inline void set_facet_idx(::google::protobuf::uint32 value);
  
  // required uint32 member_idx = 2;
  inline bool has_member_idx() const;
  inline void clear_member_idx();
  static const int kMemberIdxFieldNumber = 2;
  inline ::google::protobuf::uint32 member_idx() const;
  inline void set_member_idx(::google::protobuf::uint32 value);
  
  // required bool has_return = 3;
  inline bool has_has_return() const;
  inline void clear_has_return();
  static const int kHasReturnFieldNumber = 3;
  inline bool has_return() const;
  inline void set_has_return(bool value);
  
  // repeated .reef.Argument arguments = 4;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 4;
  inline const ::reef::Argument& arguments(int index) const;
  inline ::reef::Argument* mutable_arguments(int index);
  inline ::reef::Argument* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::reef::Argument >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::reef::Argument >*
      mutable_arguments();
  
  // @@protoc_insertion_point(class_scope:reef.Message_Member)
 private:
  inline void set_has_facet_idx();
  inline void clear_has_facet_idx();
  inline void set_has_member_idx();
  inline void clear_has_member_idx();
  inline void set_has_has_return();
  inline void clear_has_has_return();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 facet_idx_;
  ::google::protobuf::uint32 member_idx_;
  ::google::protobuf::RepeatedPtrField< ::reef::Argument > arguments_;
  bool has_return_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message_Member* default_instance_;
};
// -------------------------------------------------------------------

class Message_New : public ::google::protobuf::Message {
 public:
  Message_New();
  virtual ~Message_New();
  
  Message_New(const Message_New& from);
  
  inline Message_New& operator=(const Message_New& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_New& default_instance();
  
  void Swap(Message_New* other);
  
  // implements Message ----------------------------------------------
  
  Message_New* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_New& from);
  void MergeFrom(const Message_New& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string component_type_name = 1;
  inline bool has_component_type_name() const;
  inline void clear_component_type_name();
  static const int kComponentTypeNameFieldNumber = 1;
  inline const ::std::string& component_type_name() const;
  inline void set_component_type_name(const ::std::string& value);
  inline void set_component_type_name(const char* value);
  inline void set_component_type_name(const char* value, size_t size);
  inline ::std::string* mutable_component_type_name();
  inline ::std::string* release_component_type_name();
  
  // @@protoc_insertion_point(class_scope:reef.Message_New)
 private:
  inline void set_has_component_type_name();
  inline void clear_has_component_type_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* component_type_name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message_New* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();
  
  Message(const Message& from);
  
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();
  
  void Swap(Message* other);
  
  // implements Message ----------------------------------------------
  
  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 instance_id = 1;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 instance_id() const;
  inline void set_instance_id(::google::protobuf::uint32 value);
  
  // optional .reef.Message_New msg_new = 2;
  inline bool has_msg_new() const;
  inline void clear_msg_new();
  static const int kMsgNewFieldNumber = 2;
  inline const ::reef::Message_New& msg_new() const;
  inline ::reef::Message_New* mutable_msg_new();
  inline ::reef::Message_New* release_msg_new();
  
  // optional .reef.Message_Member msg_member = 3;
  inline bool has_msg_member() const;
  inline void clear_msg_member();
  static const int kMsgMemberFieldNumber = 3;
  inline const ::reef::Message_Member& msg_member() const;
  inline ::reef::Message_Member* mutable_msg_member();
  inline ::reef::Message_Member* release_msg_member();
  
  // @@protoc_insertion_point(class_scope:reef.Message)
 private:
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_msg_new();
  inline void clear_has_msg_new();
  inline void set_has_msg_member();
  inline void clear_has_msg_member();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::reef::Message_New* msg_new_;
  ::reef::Message_Member* msg_member_;
  ::google::protobuf::uint32 instance_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Message_2eproto();
  friend void protobuf_AssignDesc_Message_2eproto();
  friend void protobuf_ShutdownFile_Message_2eproto();
  
  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Data_Container

// optional bool boolean = 1;
inline bool Data_Container::has_boolean() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data_Container::set_has_boolean() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data_Container::clear_has_boolean() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data_Container::clear_boolean() {
  boolean_ = false;
  clear_has_boolean();
}
inline bool Data_Container::boolean() const {
  return boolean_;
}
inline void Data_Container::set_boolean(bool value) {
  set_has_boolean();
  boolean_ = value;
}

// optional string str = 2;
inline bool Data_Container::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data_Container::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data_Container::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data_Container::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Data_Container::str() const {
  return *str_;
}
inline void Data_Container::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Data_Container::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Data_Container::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Data_Container::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Data_Container::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double numeric = 3;
inline bool Data_Container::has_numeric() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Data_Container::set_has_numeric() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Data_Container::clear_has_numeric() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Data_Container::clear_numeric() {
  numeric_ = 0;
  clear_has_numeric();
}
inline double Data_Container::numeric() const {
  return numeric_;
}
inline void Data_Container::set_numeric(double value) {
  set_has_numeric();
  numeric_ = value;
}

// optional .reef.Ref_Type ref_type = 4;
inline bool Data_Container::has_ref_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Data_Container::set_has_ref_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Data_Container::clear_has_ref_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Data_Container::clear_ref_type() {
  if (ref_type_ != NULL) ref_type_->::reef::Ref_Type::Clear();
  clear_has_ref_type();
}
inline const ::reef::Ref_Type& Data_Container::ref_type() const {
  return ref_type_ != NULL ? *ref_type_ : *default_instance_->ref_type_;
}
inline ::reef::Ref_Type* Data_Container::mutable_ref_type() {
  set_has_ref_type();
  if (ref_type_ == NULL) ref_type_ = new ::reef::Ref_Type;
  return ref_type_;
}
inline ::reef::Ref_Type* Data_Container::release_ref_type() {
  clear_has_ref_type();
  ::reef::Ref_Type* temp = ref_type_;
  ref_type_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Argument

// repeated .reef.Data_Container data = 1;
inline int Argument::data_size() const {
  return data_.size();
}
inline void Argument::clear_data() {
  data_.Clear();
}
inline const ::reef::Data_Container& Argument::data(int index) const {
  return data_.Get(index);
}
inline ::reef::Data_Container* Argument::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::reef::Data_Container* Argument::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >&
Argument::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::reef::Data_Container >*
Argument::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// Ref_Type

// required .reef.Ref_Type.Owner owner = 1;
inline bool Ref_Type::has_owner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ref_Type::set_has_owner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ref_Type::clear_has_owner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ref_Type::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::reef::Ref_Type_Owner Ref_Type::owner() const {
  return static_cast< ::reef::Ref_Type_Owner >(owner_);
}
inline void Ref_Type::set_owner(::reef::Ref_Type_Owner value) {
  GOOGLE_DCHECK(::reef::Ref_Type_Owner_IsValid(value));
  set_has_owner();
  owner_ = value;
}

// required uint32 instance_id = 2;
inline bool Ref_Type::has_instance_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ref_Type::set_has_instance_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ref_Type::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ref_Type::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Ref_Type::instance_id() const {
  return instance_id_;
}
inline void Ref_Type::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// required uint32 facet_idx = 3;
inline bool Ref_Type::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ref_Type::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ref_Type::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ref_Type::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Ref_Type::facet_idx() const {
  return facet_idx_;
}
inline void Ref_Type::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// optional string owner_ip = 4;
inline bool Ref_Type::has_owner_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ref_Type::set_has_owner_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ref_Type::clear_has_owner_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ref_Type::clear_owner_ip() {
  if (owner_ip_ != &::google::protobuf::internal::kEmptyString) {
    owner_ip_->clear();
  }
  clear_has_owner_ip();
}
inline const ::std::string& Ref_Type::owner_ip() const {
  return *owner_ip_;
}
inline void Ref_Type::set_owner_ip(const ::std::string& value) {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  owner_ip_->assign(value);
}
inline void Ref_Type::set_owner_ip(const char* value) {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  owner_ip_->assign(value);
}
inline void Ref_Type::set_owner_ip(const char* value, size_t size) {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  owner_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ref_Type::mutable_owner_ip() {
  set_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    owner_ip_ = new ::std::string;
  }
  return owner_ip_;
}
inline ::std::string* Ref_Type::release_owner_ip() {
  clear_has_owner_ip();
  if (owner_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_ip_;
    owner_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Message_Member

// required uint32 facet_idx = 1;
inline bool Message_Member::has_facet_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Member::set_has_facet_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Member::clear_has_facet_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Member::clear_facet_idx() {
  facet_idx_ = 0u;
  clear_has_facet_idx();
}
inline ::google::protobuf::uint32 Message_Member::facet_idx() const {
  return facet_idx_;
}
inline void Message_Member::set_facet_idx(::google::protobuf::uint32 value) {
  set_has_facet_idx();
  facet_idx_ = value;
}

// required uint32 member_idx = 2;
inline bool Message_Member::has_member_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Member::set_has_member_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Member::clear_has_member_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Member::clear_member_idx() {
  member_idx_ = 0u;
  clear_has_member_idx();
}
inline ::google::protobuf::uint32 Message_Member::member_idx() const {
  return member_idx_;
}
inline void Message_Member::set_member_idx(::google::protobuf::uint32 value) {
  set_has_member_idx();
  member_idx_ = value;
}

// required bool has_return = 3;
inline bool Message_Member::has_has_return() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Member::set_has_has_return() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Member::clear_has_has_return() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Member::clear_has_return() {
  has_return_ = false;
  clear_has_has_return();
}
inline bool Message_Member::has_return() const {
  return has_return_;
}
inline void Message_Member::set_has_return(bool value) {
  set_has_has_return();
  has_return_ = value;
}

// repeated .reef.Argument arguments = 4;
inline int Message_Member::arguments_size() const {
  return arguments_.size();
}
inline void Message_Member::clear_arguments() {
  arguments_.Clear();
}
inline const ::reef::Argument& Message_Member::arguments(int index) const {
  return arguments_.Get(index);
}
inline ::reef::Argument* Message_Member::mutable_arguments(int index) {
  return arguments_.Mutable(index);
}
inline ::reef::Argument* Message_Member::add_arguments() {
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::reef::Argument >&
Message_Member::arguments() const {
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::reef::Argument >*
Message_Member::mutable_arguments() {
  return &arguments_;
}

// -------------------------------------------------------------------

// Message_New

// required string component_type_name = 1;
inline bool Message_New::has_component_type_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_New::set_has_component_type_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_New::clear_has_component_type_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_New::clear_component_type_name() {
  if (component_type_name_ != &::google::protobuf::internal::kEmptyString) {
    component_type_name_->clear();
  }
  clear_has_component_type_name();
}
inline const ::std::string& Message_New::component_type_name() const {
  return *component_type_name_;
}
inline void Message_New::set_component_type_name(const ::std::string& value) {
  set_has_component_type_name();
  if (component_type_name_ == &::google::protobuf::internal::kEmptyString) {
    component_type_name_ = new ::std::string;
  }
  component_type_name_->assign(value);
}
inline void Message_New::set_component_type_name(const char* value) {
  set_has_component_type_name();
  if (component_type_name_ == &::google::protobuf::internal::kEmptyString) {
    component_type_name_ = new ::std::string;
  }
  component_type_name_->assign(value);
}
inline void Message_New::set_component_type_name(const char* value, size_t size) {
  set_has_component_type_name();
  if (component_type_name_ == &::google::protobuf::internal::kEmptyString) {
    component_type_name_ = new ::std::string;
  }
  component_type_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_New::mutable_component_type_name() {
  set_has_component_type_name();
  if (component_type_name_ == &::google::protobuf::internal::kEmptyString) {
    component_type_name_ = new ::std::string;
  }
  return component_type_name_;
}
inline ::std::string* Message_New::release_component_type_name() {
  clear_has_component_type_name();
  if (component_type_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = component_type_name_;
    component_type_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Message

// required uint32 instance_id = 1;
inline bool Message::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_instance_id() {
  instance_id_ = 0u;
  clear_has_instance_id();
}
inline ::google::protobuf::uint32 Message::instance_id() const {
  return instance_id_;
}
inline void Message::set_instance_id(::google::protobuf::uint32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// optional .reef.Message_New msg_new = 2;
inline bool Message::has_msg_new() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_msg_new() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_msg_new() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_msg_new() {
  if (msg_new_ != NULL) msg_new_->::reef::Message_New::Clear();
  clear_has_msg_new();
}
inline const ::reef::Message_New& Message::msg_new() const {
  return msg_new_ != NULL ? *msg_new_ : *default_instance_->msg_new_;
}
inline ::reef::Message_New* Message::mutable_msg_new() {
  set_has_msg_new();
  if (msg_new_ == NULL) msg_new_ = new ::reef::Message_New;
  return msg_new_;
}
inline ::reef::Message_New* Message::release_msg_new() {
  clear_has_msg_new();
  ::reef::Message_New* temp = msg_new_;
  msg_new_ = NULL;
  return temp;
}

// optional .reef.Message_Member msg_member = 3;
inline bool Message::has_msg_member() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_msg_member() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_msg_member() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_msg_member() {
  if (msg_member_ != NULL) msg_member_->::reef::Message_Member::Clear();
  clear_has_msg_member();
}
inline const ::reef::Message_Member& Message::msg_member() const {
  return msg_member_ != NULL ? *msg_member_ : *default_instance_->msg_member_;
}
inline ::reef::Message_Member* Message::mutable_msg_member() {
  set_has_msg_member();
  if (msg_member_ == NULL) msg_member_ = new ::reef::Message_Member;
  return msg_member_;
}
inline ::reef::Message_Member* Message::release_msg_member() {
  clear_has_msg_member();
  ::reef::Message_Member* temp = msg_member_;
  msg_member_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace reef

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::reef::Ref_Type_Owner>() {
  return ::reef::Ref_Type_Owner_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Message_2eproto__INCLUDED
