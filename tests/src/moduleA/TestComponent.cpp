/*
 * Component implementation template for 'moduleA.TestComponent'.
 * WARNING: remember to copy this file to your project dir before you begin to change it.
 * Generated by the Coral Compiler v0.7.0 on Thu Mar 01 15:35:26 2012.p
 */

#include "TestComponent_Base.h"
#include <moduleA/MotherStruct.h>
#include <co/RefPtr.h>

namespace moduleA {

class TestComponent : public TestComponent_Base
{
public:
	TestComponent()
	{
		// empty constructor
	}

	virtual ~TestComponent()
	{
		// empty destructor
	}

	// ------ moduleA.IComplexTypes Methods ------ //

	const moduleA::StringNativeClass& getStringNativeClass()
	{
		return _stringNativeClass;
	}

	void setStringNativeClass( const moduleA::StringNativeClass& stringNativeClass )
	{
		_stringNativeClass = stringNativeClass;
	}

	const moduleA::MotherStruct& getMotherStruct()
	{
		return _motherStruct;
	}

	void setMotherStruct( const moduleA::MotherStruct& motherStruct )
	{
		_motherStruct = motherStruct;
	}

	// ------ moduleA.IReferenceTypes Methods ------ //
    
    void setSimple( moduleA::ISimpleTypes* simple )
    {
        _storedSimple = simple;
    }
    
    void setParentSimple( moduleA::ISimpleTypes* simple )
    {
        _storedParentSimple = simple;
    }
    
    moduleA::ISimpleTypes* getSimple()
    {
        return _storedSimple.get();
    }
    
    moduleA::ISimpleTypes* getParentSimple()
    {
        return _storedParentSimple.get();
    }
    
    co::int32 intFromSimple()
    {
        return _storedSimple->getStoredInt();
    }
    
    co::int32 intFromSimpleFromRef( IReferenceTypes* reference, ISimpleTypes* simple )
    {
        return reference->getSimple()->getStoredInt() + reference->callIncrementInt( simple, 1 );
    }
    
    co::int32 meth1( IReferenceTypes* ref2, IReferenceTypes* ref3, IReferenceTypes* ref4, 
                    IReferenceTypes* ref5, ISimpleTypes* simple )
    {
        return ref2->meth2( ref3, ref4, ref5, simple );
    }
    
    co::int32 meth2( IReferenceTypes* ref3, IReferenceTypes* ref4, 
                    IReferenceTypes* ref5, ISimpleTypes* simple )
    {
        return ref3->meth3( ref4, ref5, simple );
    }
    
    co::int32 meth3( IReferenceTypes* ref4, IReferenceTypes* ref5, ISimpleTypes* simple )
    {
        return ref4->meth4( ref5, simple );
    }
    
    co::int32 meth4( IReferenceTypes* ref5, ISimpleTypes* simple )
    {
        return ref5->meth5( simple );
    }
    
    co::int32 meth5( ISimpleTypes* simple )
    {
        return simple->incrementInt( simple->getStoredInt() );
    }
    
	double callDivideDouble( moduleA::ISimpleTypes* service, double dividend, double divisor )
	{
		return service->divide( dividend, divisor );
	}
    
	co::int32 callIncrementInt( moduleA::ISimpleTypes* service, co::int32 number )
	{
		return service->incrementInt( number );
	}
    
    co::int32 parentCall( moduleA::ISimpleTypes* service, co::int32 number )
	{
		return service->incrementInt( number );
	}
    
	const std::string& concatenateString( moduleA::ISimpleTypes* service, const std::string& str1, const std::string& str2 )
	{
		_storedString = service->concatenateString( str1, str2 );
        return _storedString;
	}

	// ------ moduleA.ISimpleTypes Methods ------ //

	double getStoredDouble()
	{
		return _storedDouble;
	}

	void setStoredDouble( double storedDouble )
	{
		_storedDouble = storedDouble;
	}

	co::Range<double const> getStoredDoubleList()
	{
		return _storedDoubleList;
	}

	void setStoredDoubleList( co::Range<double const> storedDoubleList )
	{
		co::assign( storedDoubleList, _storedDoubleList );
	}

	co::int32 getStoredInt()
	{
		return _storedInt;
	}

	void setStoredInt( co::int32 storedInt )
	{
		_storedInt = storedInt;
	}
    
    co::int32 getParentInt()
	{
		return _storedParentInt;
	}
    
	void setGrandParentInt( co::int32 gParentInt )
	{
		_storedGParentInt = gParentInt;
	}
    
    co::int32 getGrandParentInt()
	{
		return _storedGParentInt;
	}
    
	void setParentInt( co::int32 parentInt )
	{
		_storedParentInt = parentInt;
	}

	co::Range<co::int32 const> getStoredIntList()
	{
		return _storedIntList;
	}

	void setStoredIntList( co::Range<co::int32 const> storedIntList )
	{
		co::assign( storedIntList, _storedIntList );
	}

	const std::string& getStoredString()
	{
		return _storedString;
	}

	void setStoredString( const std::string& storedString )
	{
		_storedString = storedString;
	}

	co::Range<std::string const> getStoredStringList()
	{
		return _storedStringList;
	}

	void setStoredStringList( co::Range<std::string const> storedStringList )
	{
		co::assign( storedStringList, _storedStringList );
	}

    co::Range<std::string const> getParentStringList()
	{
		return _storedParentStringList;
	}
    
	void setParentStringList( co::Range<std::string const> parentStringList )
	{
		co::assign( parentStringList, _storedParentStringList );
	}
    
	// -------------------- Methods --------------------- //

	const std::string& concatenateString( const std::string& str1, const std::string& str2 )
	{
		_storedString = str1;
		_storedString.append( str2 );
		return _storedString;
	}

	double divide( double dividend, double divisor )
	{
		return dividend / divisor;
	}

	co::Range<co::int32 const> get10Ints()
	{
		_storedIntList.clear();

		for( int i = 0; i < 10; i++ )
			_storedIntList.push_back( i );

		return _storedIntList;
	}

	co::Range<std::string const> getAlphabetList()
	{
		_storedStringList.clear();

		for( int i = 0; i < 24; i++ )
		{
			char letter[2];
			letter[0] = 65 + i;
			letter[1] = '\0';
			_storedStringList.push_back( letter );
		}

		return _storedStringList;
	}

	const std::string& getHelloString()
	{
		_storedString.assign( "Hello" );
		return _storedString;
	}

	double getNumber4Double()
	{
		return 4.0;
	}

	co::int32 getNumber4Int()
	{
		return 4;
	}

	co::Range<std::string const> getThirdElements( co::Range<std::string const> list1, co::Range<std::string const> list2 )
	{
		_storedStringList.clear();

		_storedStringList.push_back( list1[2] );
		_storedStringList.push_back( list2[2] );

		return _storedStringList;
	}

	co::int32 incrementInt( co::int32 number )
	{
		number++;
		return number;
	}

	co::Range<double const> mergeLists( co::Range<double const> list1, co::Range<double const> list2 )
	{
		_storedDoubleList.clear();

		co::assign( list1, _storedDoubleList );

		for( ; list2; list2.popFirst() )
		{
			_storedDoubleList.push_back( list2.getFirst() );
		}

		return _storedDoubleList;
	}

    const co::Any& addDoublesFromAny( const co::Any& d1, const co::Any& d2 )
	{
		static co::Any anyDouble;
        anyDouble.set<double>( d1.get<double>() + d2.get<double>() );
		return anyDouble;
	}
    
	const co::Any& concatenateFromAny( const co::Any& str1, const co::Any& str2 )
	{
		static co::Any anyString;
        std::string& temp = anyString.createString();
        temp = str1.get<const std::string&>();
		temp.append( str2.get<const std::string&>() );
        anyString.set<const std::string&>( temp );
		return anyString;
	}
    
    const co::Any& mergeListsFromAny( const co::Any& l1, const co::Any& l2 )
	{
        // NYI
        assert( false );
        static co::Any dummy;
		return dummy;
	}
    
    co::Range<double const> parentMergeLists( co::Range<double const> list1, co::Range<double const> list2 )
	{
		_storedParentDoubleList.clear();
        
		co::assign( list1, _storedParentDoubleList );
        
		for( ; list2; list2.popFirst() )
		{
			_storedParentDoubleList.push_back( list2.getFirst() );
		}
        
        return _storedParentDoubleList;
	}
    
    double parentMultiply( double number, co::int32 times )
    {
        return number * times;
    }
    
	void setDouble( double number )
	{
		_storedDouble = number;
	}

	void setInt( co::int32 number )
	{
		_storedInt = number;
	}

	void setIntList( co::Range<co::int32 const> intList )
	{
		co::assign( intList, _storedIntList );
	}

	void setStrList( co::Range<std::string const> strList )
	{
		co::assign( strList, _storedStringList );
	}

	void setString( const std::string& str )
	{
		_storedString = str;
	}

private:
    co::RefPtr<moduleA::ISimpleTypes> _storedSimple;
    co::RefPtr<moduleA::ISimpleTypes> _storedParentSimple;
    
	// member variables
	moduleA::StringNativeClass _stringNativeClass;
	moduleA::MotherStruct _motherStruct;
	co::int32 _dummy;
	double _storedDouble;
	std::vector<double> _storedDoubleList;
    std::vector<double> _storedParentDoubleList;
	co::int32 _storedInt;
    co::int32 _storedParentInt;
    co::int32 _storedGParentInt;
	std::vector<co::int32> _storedIntList;
	std::string _storedString;
	std::vector<std::string> _storedStringList;
    std::vector<std::string> _storedParentStringList;
};

CORAL_EXPORT_COMPONENT( TestComponent, TestComponent );

} // namespace moduleA
